// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef ECL_HXX
#define ECL_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>  // if missing: ksu; yum install xsd;

#if(XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>

#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/xml/dom/serialization-header.hxx>

#include <xsd/cxx/tree/std-ostream-operators.hxx>

namespace xml_schema
{
// anyType and anySimpleType.
//
typedef ::xsd::cxx::tree::type                    type;
typedef ::xsd::cxx::tree::simple_type<char, type> simple_type;
typedef ::xsd::cxx::tree::type                    container;

// 8-bit
//
typedef signed char   byte;
typedef unsigned char unsigned_byte;

// 16-bit
//
typedef short          short_;
typedef unsigned short unsigned_short;

// 32-bit
//
typedef int          int_;
typedef unsigned int unsigned_int;

// 64-bit
//
typedef long long          long_;
typedef unsigned long long unsigned_long;

// Supposed to be arbitrary-length integral types.
//
typedef long long          integer;
typedef long long          non_positive_integer;
typedef unsigned long long non_negative_integer;
typedef unsigned long long positive_integer;
typedef long long          negative_integer;

// Boolean.
//
typedef bool boolean;

// Floating-point types.
//
typedef float  float_;
typedef double double_;
typedef double decimal;

// String types.
//
typedef ::xsd::cxx::tree::string<char, simple_type>            string;
typedef ::xsd::cxx::tree::normalized_string<char, string>      normalized_string;
typedef ::xsd::cxx::tree::token<char, normalized_string>       token;
typedef ::xsd::cxx::tree::name<char, token>                    name;
typedef ::xsd::cxx::tree::nmtoken<char, token>                 nmtoken;
typedef ::xsd::cxx::tree::nmtokens<char, simple_type, nmtoken> nmtokens;
typedef ::xsd::cxx::tree::ncname<char, name>                   ncname;
typedef ::xsd::cxx::tree::language<char, token>                language;

// ID/IDREF.
//
typedef ::xsd::cxx::tree::id<char, ncname>                 id;
typedef ::xsd::cxx::tree::idref<char, ncname, type>        idref;
typedef ::xsd::cxx::tree::idrefs<char, simple_type, idref> idrefs;

// URI.
//
typedef ::xsd::cxx::tree::uri<char, simple_type> uri;

// Qualified name.
//
typedef ::xsd::cxx::tree::qname<char, simple_type, uri, ncname> qname;

// Binary.
//
typedef ::xsd::cxx::tree::buffer<char>                     buffer;
typedef ::xsd::cxx::tree::base64_binary<char, simple_type> base64_binary;
typedef ::xsd::cxx::tree::hex_binary<char, simple_type>    hex_binary;

// Date/time.
//
typedef ::xsd::cxx::tree::time_zone                      time_zone;
typedef ::xsd::cxx::tree::date<char, simple_type>        date;
typedef ::xsd::cxx::tree::date_time<char, simple_type>   date_time;
typedef ::xsd::cxx::tree::duration<char, simple_type>    duration;
typedef ::xsd::cxx::tree::gday<char, simple_type>        gday;
typedef ::xsd::cxx::tree::gmonth<char, simple_type>      gmonth;
typedef ::xsd::cxx::tree::gmonth_day<char, simple_type>  gmonth_day;
typedef ::xsd::cxx::tree::gyear<char, simple_type>       gyear;
typedef ::xsd::cxx::tree::gyear_month<char, simple_type> gyear_month;
typedef ::xsd::cxx::tree::time<char, simple_type>        time;

// Entity.
//
typedef ::xsd::cxx::tree::entity<char, ncname>                entity;
typedef ::xsd::cxx::tree::entities<char, simple_type, entity> entities;

typedef ::xsd::cxx::tree::content_order content_order;
// Namespace information and list stream. Used in
// serialization functions.
//
typedef ::xsd::cxx::xml::dom::namespace_info<char>    namespace_info;
typedef ::xsd::cxx::xml::dom::namespace_infomap<char> namespace_infomap;
typedef ::xsd::cxx::tree::list_stream<char>           list_stream;
typedef ::xsd::cxx::tree::as_double<double_>          as_double;
typedef ::xsd::cxx::tree::as_decimal<decimal>         as_decimal;
typedef ::xsd::cxx::tree::facet                       facet;

// Flags and properties.
//
typedef ::xsd::cxx::tree::flags            flags;
typedef ::xsd::cxx::tree::properties<char> properties;

// Parsing/serialization diagnostics.
//
typedef ::xsd::cxx::tree::severity          severity;
typedef ::xsd::cxx::tree::error<char>       error;
typedef ::xsd::cxx::tree::diagnostics<char> diagnostics;

// Exceptions.
//
typedef ::xsd::cxx::tree::exception<char>             exception;
typedef ::xsd::cxx::tree::bounds<char>                bounds;
typedef ::xsd::cxx::tree::duplicate_id<char>          duplicate_id;
typedef ::xsd::cxx::tree::parsing<char>               parsing;
typedef ::xsd::cxx::tree::expected_element<char>      expected_element;
typedef ::xsd::cxx::tree::unexpected_element<char>    unexpected_element;
typedef ::xsd::cxx::tree::expected_attribute<char>    expected_attribute;
typedef ::xsd::cxx::tree::unexpected_enumerator<char> unexpected_enumerator;
typedef ::xsd::cxx::tree::expected_text_content<char> expected_text_content;
typedef ::xsd::cxx::tree::no_prefix_mapping<char>     no_prefix_mapping;
typedef ::xsd::cxx::tree::serialization<char>         serialization;

// Error handler callback interface.
//
typedef ::xsd::cxx::xml::error_handler<char> error_handler;

// DOM interaction.
//
namespace dom
{
// Automatic pointer for DOMDocument.
//
using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
// DOM user data key for back pointers to tree nodes.
//
const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
}
}

// Forward declarations.
//
class Tag_t;
class Attachment_t;
class Field_t;
class Form_t;
class ECLEntry_t;

#include <algorithm>  // std::binary_search
#include <limits>     // std::numeric_limits
#include <memory>     // ::std::unique_ptr
#include <utility>    // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

class Tag_t : public ::xml_schema::type
{
  public:
	// name
	//
	typedef ::xml_schema::string                      name_type;
	typedef ::xsd::cxx::tree::traits<name_type, char> name_traits;

	const name_type& name() const;

	name_type& name();

	void name(const name_type& x);

	void name(::std::unique_ptr<name_type> p);

	// Constructors.
	//
	Tag_t();

	Tag_t(const name_type&);

	Tag_t(const ::xercesc::DOMElement& e,
	      ::xml_schema::flags          f = 0,
	      ::xml_schema::container*     c = 0);

	Tag_t(const Tag_t& x, ::xml_schema::flags f = 0, ::xml_schema::container* c = 0);

	virtual Tag_t* _clone(::xml_schema::flags      f = 0,
	                      ::xml_schema::container* c = 0) const;

	Tag_t& operator=(const Tag_t& x);

	virtual ~Tag_t();

	// Implementation.
	//
  protected:
	void parse(::xsd::cxx::xml::dom::parser<char>&, ::xml_schema::flags);

  protected:
	::xsd::cxx::tree::one<name_type> name_;
};

class Attachment_t : public ::xml_schema::base64_binary
{
  public:
	// type
	//
	typedef ::xml_schema::string                      type_type;
	typedef ::xsd::cxx::tree::traits<type_type, char> type_traits;

	const type_type& type() const;

	type_type& type();

	void type(const type_type& x);

	void type(::std::unique_ptr<type_type> p);

	// filename
	//
	typedef ::xml_schema::string                          filename_type;
	typedef ::xsd::cxx::tree::traits<filename_type, char> filename_traits;

	const filename_type& filename() const;

	filename_type& filename();

	void filename(const filename_type& x);

	void filename(::std::unique_ptr<filename_type> p);

	// Constructors.
	//
	Attachment_t();

	Attachment_t(const type_type&, const filename_type&);

	Attachment_t(const ::xml_schema::base64_binary&,
	             const type_type&,
	             const filename_type&);

	Attachment_t(const ::xercesc::DOMElement& e,
	             ::xml_schema::flags          f = 0,
	             ::xml_schema::container*     c = 0);

	Attachment_t(const Attachment_t&      x,
	             ::xml_schema::flags      f = 0,
	             ::xml_schema::container* c = 0);

	virtual Attachment_t* _clone(::xml_schema::flags      f = 0,
	                             ::xml_schema::container* c = 0) const;

	Attachment_t& operator=(const Attachment_t& x);

	virtual ~Attachment_t();

	// Implementation.
	//
  protected:
	void parse(::xsd::cxx::xml::dom::parser<char>&, ::xml_schema::flags);

  protected:
	::xsd::cxx::tree::one<type_type>     type_;
	::xsd::cxx::tree::one<filename_type> filename_;
};

class Field_t : public ::xml_schema::string
{
  public:
	// name
	//
	typedef ::xml_schema::string                      name_type;
	typedef ::xsd::cxx::tree::traits<name_type, char> name_traits;

	const name_type& name() const;

	name_type& name();

	void name(const name_type& x);

	void name(::std::unique_ptr<name_type> p);

	// Constructors.
	//
	Field_t();

	Field_t(const name_type&);

	Field_t(const char*, const name_type&);

	Field_t(const ::std::string&, const name_type&);

	Field_t(const ::xml_schema::string&, const name_type&);

	Field_t(const ::xercesc::DOMElement& e,
	        ::xml_schema::flags          f = 0,
	        ::xml_schema::container*     c = 0);

	Field_t(const Field_t& x, ::xml_schema::flags f = 0, ::xml_schema::container* c = 0);

	virtual Field_t* _clone(::xml_schema::flags      f = 0,
	                        ::xml_schema::container* c = 0) const;

	Field_t& operator=(const Field_t& x);

	virtual ~Field_t();

	// Implementation.
	//
  protected:
	void parse(::xsd::cxx::xml::dom::parser<char>&, ::xml_schema::flags);

  protected:
	::xsd::cxx::tree::one<name_type> name_;
};

class Form_t : public ::xml_schema::type
{
  public:
	// field
	//
	typedef ::Field_t                                  field_type;
	typedef ::xsd::cxx::tree::sequence<field_type>     field_sequence;
	typedef field_sequence::iterator                   field_iterator;
	typedef field_sequence::const_iterator             field_const_iterator;
	typedef ::xsd::cxx::tree::traits<field_type, char> field_traits;

	const field_sequence& field() const;

	field_sequence& field();

	void field(const field_sequence& s);

	// name
	//
	typedef ::xml_schema::string                      name_type;
	typedef ::xsd::cxx::tree::traits<name_type, char> name_traits;

	const name_type& name() const;

	name_type& name();

	void name(const name_type& x);

	void name(::std::unique_ptr<name_type> p);

	// Constructors.
	//
	Form_t();

	Form_t(const name_type&);

	Form_t(const ::xercesc::DOMElement& e,
	       ::xml_schema::flags          f = 0,
	       ::xml_schema::container*     c = 0);

	Form_t(const Form_t& x, ::xml_schema::flags f = 0, ::xml_schema::container* c = 0);

	virtual Form_t* _clone(::xml_schema::flags      f = 0,
	                       ::xml_schema::container* c = 0) const;

	Form_t& operator=(const Form_t& x);

	virtual ~Form_t();

	// Implementation.
	//
  protected:
	void parse(::xsd::cxx::xml::dom::parser<char>&, ::xml_schema::flags);

  protected:
	field_sequence                   field_;
	::xsd::cxx::tree::one<name_type> name_;
};

class ECLEntry_t : public ::xml_schema::type
{
  public:
	// tag
	//
	typedef ::Tag_t                                  tag_type;
	typedef ::xsd::cxx::tree::sequence<tag_type>     tag_sequence;
	typedef tag_sequence::iterator                   tag_iterator;
	typedef tag_sequence::const_iterator             tag_const_iterator;
	typedef ::xsd::cxx::tree::traits<tag_type, char> tag_traits;

	const tag_sequence& tag() const;

	tag_sequence& tag();

	void tag(const tag_sequence& s);

	// attachment
	//
	typedef ::Attachment_t                                  attachment_type;
	typedef ::xsd::cxx::tree::sequence<attachment_type>     attachment_sequence;
	typedef attachment_sequence::iterator                   attachment_iterator;
	typedef attachment_sequence::const_iterator             attachment_const_iterator;
	typedef ::xsd::cxx::tree::traits<attachment_type, char> attachment_traits;

	const attachment_sequence& attachment() const;

	attachment_sequence& attachment();

	void attachment(const attachment_sequence& s);

	// form
	//
	typedef ::Form_t                                  form_type;
	typedef ::xsd::cxx::tree::optional<form_type>     form_optional;
	typedef ::xsd::cxx::tree::traits<form_type, char> form_traits;

	const form_optional& form() const;

	form_optional& form();

	void form(const form_type& x);

	void form(const form_optional& x);

	void form(::std::unique_ptr<form_type> p);

	// author
	//
	typedef ::xml_schema::string                        author_type;
	typedef ::xsd::cxx::tree::traits<author_type, char> author_traits;

	const author_type& author() const;

	author_type& author();

	void author(const author_type& x);

	void author(::std::unique_ptr<author_type> p);

	// category
	//
	typedef ::xml_schema::string                          category_type;
	typedef ::xsd::cxx::tree::traits<category_type, char> category_traits;

	const category_type& category() const;

	category_type& category();

	void category(const category_type& x);

	void category(::std::unique_ptr<category_type> p);

	// Constructors.
	//
	ECLEntry_t();

	ECLEntry_t(const author_type&, const category_type&);

	ECLEntry_t(const ::xercesc::DOMElement& e,
	           ::xml_schema::flags          f = 0,
	           ::xml_schema::container*     c = 0);

	ECLEntry_t(const ECLEntry_t&        x,
	           ::xml_schema::flags      f = 0,
	           ::xml_schema::container* c = 0);

	virtual ECLEntry_t* _clone(::xml_schema::flags      f = 0,
	                           ::xml_schema::container* c = 0) const;

	ECLEntry_t& operator=(const ECLEntry_t& x);

	virtual ~ECLEntry_t();

	// Implementation.
	//
  protected:
	void parse(::xsd::cxx::xml::dom::parser<char>&, ::xml_schema::flags);

  protected:
	tag_sequence                         tag_;
	attachment_sequence                  attachment_;
	form_optional                        form_;
	::xsd::cxx::tree::one<author_type>   author_;
	::xsd::cxx::tree::one<category_type> category_;
};

#include <iosfwd>

::std::ostream& operator<<(::std::ostream&, const Tag_t&);

::std::ostream& operator<<(::std::ostream&, const Attachment_t&);

::std::ostream& operator<<(::std::ostream&, const Field_t&);

::std::ostream& operator<<(::std::ostream&, const Form_t&);

::std::ostream& operator<<(::std::ostream&, const ECLEntry_t&);

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/sax/InputSource.hpp>

// Parse a URI or a local file.
//

::std::unique_ptr< ::ECLEntry_t> entry(
    const ::std::string&            uri,
    ::xml_schema::flags             f = 0,
    const ::xml_schema::properties& p = ::xml_schema::properties());

::std::unique_ptr< ::ECLEntry_t> entry(
    const ::std::string&            uri,
    ::xml_schema::error_handler&    eh,
    ::xml_schema::flags             f = 0,
    const ::xml_schema::properties& p = ::xml_schema::properties());

::std::unique_ptr< ::ECLEntry_t> entry(
    const ::std::string&            uri,
    ::xercesc::DOMErrorHandler&     eh,
    ::xml_schema::flags             f = 0,
    const ::xml_schema::properties& p = ::xml_schema::properties());

// Parse std::istream.
//

::std::unique_ptr< ::ECLEntry_t> entry(
    ::std::istream&                 is,
    ::xml_schema::flags             f = 0,
    const ::xml_schema::properties& p = ::xml_schema::properties());

::std::unique_ptr< ::ECLEntry_t> entry(
    ::std::istream&                 is,
    ::xml_schema::error_handler&    eh,
    ::xml_schema::flags             f = 0,
    const ::xml_schema::properties& p = ::xml_schema::properties());

::std::unique_ptr< ::ECLEntry_t> entry(
    ::std::istream&                 is,
    ::xercesc::DOMErrorHandler&     eh,
    ::xml_schema::flags             f = 0,
    const ::xml_schema::properties& p = ::xml_schema::properties());

::std::unique_ptr< ::ECLEntry_t> entry(
    ::std::istream&                 is,
    const ::std::string&            id,
    ::xml_schema::flags             f = 0,
    const ::xml_schema::properties& p = ::xml_schema::properties());

::std::unique_ptr< ::ECLEntry_t> entry(
    ::std::istream&                 is,
    const ::std::string&            id,
    ::xml_schema::error_handler&    eh,
    ::xml_schema::flags             f = 0,
    const ::xml_schema::properties& p = ::xml_schema::properties());

::std::unique_ptr< ::ECLEntry_t> entry(
    ::std::istream&                 is,
    const ::std::string&            id,
    ::xercesc::DOMErrorHandler&     eh,
    ::xml_schema::flags             f = 0,
    const ::xml_schema::properties& p = ::xml_schema::properties());

// Parse xercesc::InputSource.
//

::std::unique_ptr< ::ECLEntry_t> entry(
    ::xercesc::InputSource&         is,
    ::xml_schema::flags             f = 0,
    const ::xml_schema::properties& p = ::xml_schema::properties());

::std::unique_ptr< ::ECLEntry_t> entry(
    ::xercesc::InputSource&         is,
    ::xml_schema::error_handler&    eh,
    ::xml_schema::flags             f = 0,
    const ::xml_schema::properties& p = ::xml_schema::properties());

::std::unique_ptr< ::ECLEntry_t> entry(
    ::xercesc::InputSource&         is,
    ::xercesc::DOMErrorHandler&     eh,
    ::xml_schema::flags             f = 0,
    const ::xml_schema::properties& p = ::xml_schema::properties());

// Parse xercesc::DOMDocument.
//

::std::unique_ptr< ::ECLEntry_t> entry(
    const ::xercesc::DOMDocument&   d,
    ::xml_schema::flags             f = 0,
    const ::xml_schema::properties& p = ::xml_schema::properties());

::std::unique_ptr< ::ECLEntry_t> entry(
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument> d,
    ::xml_schema::flags                                    f = 0,
    const ::xml_schema::properties& p = ::xml_schema::properties());

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

// Serialize to std::ostream.
//

void entry(::std::ostream&                        os,
           const ::ECLEntry_t&                    x,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap(),
           const ::std::string&                   e = "UTF-8",
           ::xml_schema::flags                    f = 0);

void entry(::std::ostream&                        os,
           const ::ECLEntry_t&                    x,
           ::xml_schema::error_handler&           eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap(),
           const ::std::string&                   e = "UTF-8",
           ::xml_schema::flags                    f = 0);

void entry(::std::ostream&                        os,
           const ::ECLEntry_t&                    x,
           ::xercesc::DOMErrorHandler&            eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap(),
           const ::std::string&                   e = "UTF-8",
           ::xml_schema::flags                    f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void entry(::xercesc::XMLFormatTarget&            ft,
           const ::ECLEntry_t&                    x,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap(),
           const ::std::string&                   e = "UTF-8",
           ::xml_schema::flags                    f = 0);

void entry(::xercesc::XMLFormatTarget&            ft,
           const ::ECLEntry_t&                    x,
           ::xml_schema::error_handler&           eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap(),
           const ::std::string&                   e = "UTF-8",
           ::xml_schema::flags                    f = 0);

void entry(::xercesc::XMLFormatTarget&            ft,
           const ::ECLEntry_t&                    x,
           ::xercesc::DOMErrorHandler&            eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap(),
           const ::std::string&                   e = "UTF-8",
           ::xml_schema::flags                    f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void entry(::xercesc::DOMDocument& d, const ::ECLEntry_t& x, ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument> entry(
    const ::ECLEntry_t&                    x,
    const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap(),
    ::xml_schema::flags                    f = 0);

void operator<<(::xercesc::DOMElement&, const Tag_t&);

void operator<<(::xercesc::DOMElement&, const Attachment_t&);

void operator<<(::xercesc::DOMElement&, const Field_t&);

void operator<<(::xercesc::DOMElement&, const Form_t&);

void operator<<(::xercesc::DOMElement&, const ECLEntry_t&);

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif  // ECL_HXX

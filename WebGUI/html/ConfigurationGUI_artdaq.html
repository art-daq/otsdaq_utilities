<!DOCTYPE HTML>
<html lang="en"> 
<head>
	<title>artdaq ConfigurationGUI</title>

	<link href='/WebPath/css/fonts.css?family=Inconsolata:400' rel='stylesheet' type='text/css'>
		
	<link rel="stylesheet" type="text/css" href="/WebPath/css/ConfigurationGUI.css">
	<link rel="stylesheet" type="text/css" href="/WebPath/css/ConfigurationAPI.css">

	<!-- MultiSelectBox: Must include .css style sheet and .js functionality -->
	<link rel="stylesheet" type="text/css" href="/WebPath/css/MultiSelectBox.css">
	<script type="text/JavaScript" src="/WebPath/js/js_lib/MultiSelectBox.js"></script>

	<style type="text/css">			
		
		/* CSS Reset */
		html{color:white;background:#FFF}
		body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td{margin:0;padding:0}table{border-collapse:collapse;border-spacing:0}fieldset,img{border:0}address,caption,cite,code,dfn,em,strong,th,var{font-style:normal;font-weight:normal}ol,ul{list-style:none}caption,th{text-align:left}h1,h2,h3,h4,h5,h6{font-size:100%;font-weight:normal}q:before,q:after{content:''}abbr,acronym{border:0;font-variant:normal}sup{vertical-align:text-top}sub{vertical-align:text-bottom}input,textarea,select{font-family:inherit;font-size:inherit;font-weight:inherit;*font-size:100%}
		legend{color:#000}	
		* {
			margin: 				0;
			spacing: 				0;
			padding: 				0;
			border: 				0;
			color: 					white;
			-webkit-user-select: 	none; /* prevent highlight selection (does not stop ghost images, must use el.ondragstart = function() {return false;}; */
			-moz-user-select: 		none;
			user-select:			none;
			outline: 				none;  /* to stop firefox selection*/	
			font-family: 			'Comfortaa', serif; /*'Donegal One', serif;*/		
			font-size: 				20px;
		}
		
		/* make buttons and links have a hand cursor */
		input[type="button"], button, a {
			cursor: pointer;
		}
		
		#theGridCanvas, #theCanvas, #theActionCanvas, #preCanvas, #postCanvas {
			position: 				absolute;
			left: 					0;
			top: 					0;
		}
		#theCanvas, #theActionCanvas {
			z-index:				1000;			
		}
		.node-point /*place on top of the canvas*/ {
			z-index:				1001;
		}
				
		.node {
			position:				absolute;
			cursor:					pointer;			
		}
		
		.node-box {
			background-color : 		rgb(241, 231, 231);
			overflow: 				auto;

			box-shadow: 			inset rgba(255,254,255,0.6) 0 0.3em .3em,
									inset rgba(0,0,0,0.15) 0 -0.1em .3em, /* inner shadow */
									rgba(200, 200, 200,0.6) 0 .1em 3px,
									rgba(200, 200, 200,0.6) 0 .1em 1px,  /* color border */
									rgba(0,0,0,0.2) 0 .5em 5px;	/* drop shadow */
			border-radius: 			3px;	
			
			position:				absolute;
			cursor:					pointer;
		}
		
		.node-box:hover {

			background-color: 		rgb(230, 201, 201);

			box-shadow: 			inset rgba(255,254,255,0.6) 0 0.3em .3em,
									inset rgba(0,0,0,0.15) 0 -0.1em .3em, /* inner shadow */
									rgba(200, 200, 200,0.6) 0 .1em 3px,
									rgba(200, 200, 200,0.6) 0 .1em 1px,  /* color border */
									rgba(0,0,0,0.2) 0 .5em 5px;	/* drop shadow */
		}		
		
		.node-point {
			background-color : 		rgb(206, 148, 148);
			border:					3px solid rgb(132, 92, 92);
			border-radius: 			9px;	
			width:					9px;
			height:					9px;

			box-shadow: 			inset rgba(255,254,255,0.6) 0 0.3em .3em,
									inset rgba(0,0,0,0.15) 0 -0.1em .3em, /* inner shadow */
									rgba(200, 200, 200, 0.6) 0 0 3px,
									rgba(200, 200, 200, 0.6) 0 0 1px,  /* color border */
									rgba(0,0,0,0.2) 0 0 5px;	/* drop shadow */
			
			position:				absolute;
			cursor:					pointer;
			display:				none;
		}
			
		.node-point:hover {
			background-color: 		rgb(230, 201, 201);
		}
		
		
		
		#createNodeDiv {
			background-color: 		rgb(195, 230, 193);	
			cursor:					pointer;
			width: 					32px;
			height: 				32px;
			border-radius: 			32px;
			border: 				2px solid rgb(6, 82, 9);
			
			box-shadow: 			inset rgba(255,254,255,0.6) 0 0.3em .3em,
									inset rgba(0,0,0,0.15) 0 -0.1em .3em, /* inner shadow */
									rgba(200, 200, 200,0.6) 0 .1em 3px,
									rgba(200, 200, 200,0.6) 0 .1em 1px,  /* color border */
									rgba(0,0,0,0.2) 0 .3em 5px;	/* drop shadow */
			
			left:					-1000px;			
			position: 				absolute;
		    z-index:				2000; 	/* to place on top of everything */
		}
		
		#createNodeDiv:hover {
			background-color: 		rgb(215, 255, 213);			
		}

		#createNode {
			margin: 				1px 16px -10px 8px;
			float:					left;
			
			text-decoration: 		none;			
			font-size: 				30px;
			font-weight: 			bold;
			color: 					rgb(15, 152, 76);
		}
		
		
		.treeNode-Value-editIcon {			
			background-image: 	url(/WebPath/images/windowContentImages/ConfigurationGUI-pencilEdit.png);
			width: 				24px;
			height: 			20px;
			float: 				left;
			border: 			0;
			margin: 			-2px 0 -7px 10px;
			display:			none;
		}
		.treeNode-Value-editIcon:hover {
			background-image: 	url(/WebPath/images/windowContentImages/ConfigurationGUI-pencilEditHover.png);
			cursor: 			pointer;
		}
		
		.treeNode-deleteIcon {			
			background-image: 	url(/WebPath/images/windowContentImages/ConfigurationGUI-trashCan.png);
			width: 				16px;
			height: 			20px;
			border: 			0;
			margin: 			-9px 0 -10px 10px;
		}
		.treeNode-deleteIcon:hover {
			background-image: 	url(/WebPath/images/windowContentImages/ConfigurationGUI-trashCanHover.png);
			cursor: 			pointer;
		}
    	

		.preloadImage {			
			width: 				24px;
			height: 			20px;
			position:			absolute;
			left: 				-100px;
			top: 				0;
		}
		#preloadImage-treeEditTrashIconHover {
			background-image: 	url(/WebPath/images/windowContentImages/ConfigurationGUI-trashCanHover.png);
		}
		#preloadImage-treeEditIconHover {
			background-image: 	url(/WebPath/images/windowContentImages/ConfigurationGUI-pencilEditHover.png);
		}
		
	</style>
	
	
	<script type="text/JavaScript" src="/WebPath/js/Globals.js"></script>	
	<script type="text/JavaScript" src="/WebPath/js/Debug.js"></script>	
	<script type="text/JavaScript" src="/WebPath/js/DesktopWindowContentCode.js"></script>
	<script type="text/JavaScript" src="/WebPath/js/js_lib/SimpleContextMenu.js"></script>
	<script type="text/JavaScript" src="/WebPath/js/js_lib/ConfigurationAPI.js"></script>
	
	<script>		
		
		//	Description of Configuration-artdaq Functionality/Behavior:
		//	
		//	- Requires user to have LOCK
		//
		//	- Grid always stretches to full window size
		//	and defines scale (allow adding row/col of dots at either side)
		//		
		//	- Save functionality should be same as saving tree	
		//		* If admin, could give options to target a certain system alias.. Etc.
		//		* Else assume saving to currently active groups
		//	- Save/Load positioning maps to filename based on active Context group.
		//
		//	- On load, get active groups artdaq modules.. allow editing, deleting, adding.. 
		//	and connecting sources and destinations
		
	
		//paint globals -------------		
		var _NODE_SIZE; //everything else should be sized off of this, and grid steps
		var _CANVAS_MARGIN		= 0;
		var _GRID_MARGIN		= 100;
		var _CANVAS_COLOR 		= "rgba(255,255,255,0)";
		var _GRID_COLOR 		= "rgb(218, 194, 194)";
		var _ARROW_COLOR 		= "rgb(70, 67, 67)";
		var _SHADOW_COLOR 		= "gray";
		var _gridCanvas, _gridContext, _canvas, _context, _actionCanvas, _actionContext;
		var _preCanvas, _postCanvas;
		var _addNodeEl;
		var _w, _h;		
		
		//object globals -------------
		var _grid = { //size of grid, rows and cols can be added or removed
				"rows": 4, 	"cols": 3, 
				"x0": 	0, 	"y0": 	0, 
				"xstep":0, 	"ystep":0}; 
		var _nodes = []; 	// array of node objects (can be multi-node vector at location)
							//	node: 	{type,x-grid,y-grid,node-count}
		var _arrows = {}; 	//multi-dim map of arrow objects 
							//	arrow:	[i0][i1] = {p0,p1} (start and end i,p - where i := node index, p := 1 of 4 positions starting from top going clock-wise)
		
		
		
		//constant globals -------------
		var _NODE_TYPE_READER 		= 0;
		var _NODE_TYPE_BUILDER 		= 1;
		var _NODE_TYPE_LOGGER 		= 2;
		var _NODE_TYPE_MONITOR 		= 3;
		var _NODE_TYPE_DISPATCHER 	= 4;
		
		var _MMM_NONE				= 0;
		var _MMM_ARROW_DRAG			= 1;
		
		//mousemove globals -------------
		var _mouseMoveMode = _MMM_NONE;
		var _mouseMoveStart = [0,0,0,0]; //x,y,i,p start (i,p are optional)
		var _mouseHoverNode = -1;
		
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
	
		//functions:			
			//init()
		
			//paint()
			//drawGrid() 
			//drawNode() 
			//drawArrow() 
		
			//getNodePoint(i,p)
			//doNodeHover(i)
			
			//handleNodeMouseOver(e)
			//handleMouseMove(e)
			//handleMouseUp(e)
			//handlePointMouseUp(i,p)
			//handlePointMouseDown(i,p)
				
	
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
				

		//=====================================================================================
		//init ~~
		//	init called once body has loaded
		function init() 
		{									
			Debug.log("CfgGUI_artdaq init ");			
			
			

			//			DesktopContent.tooltip("Configuration-Subset GUI Introduction",
			//					"Welcome to the Configuration-Subset GUI targeting " + _recordsAlias + 
			//					". Here you can manipulate the fields "+
			//					"of a subset of your <i>otsdaq</i> system. \n\n" +
			//					"The organization of the Configuration-Subset GUI is in the form of two panes, a left and right.\n\n" +
			//
			//					"Briefly, here is a description of the two panes: " +
			//					"\n\t- 'Left Pane' is for selecting one or many records to target." +
			//					"\n\t- 'Right Pane' is for modifying the common fields associated with the selected records."
			//			);

			var x = 0;
			var y = 0;
			_nodes.push({"type":_NODE_TYPE_READER,	"x":x++, 	"y":y});			
			_nodes.push({"type":_NODE_TYPE_BUILDER,	"x":x++, 	"y":y, "node-count": 5});			
			_nodes.push({"type":_NODE_TYPE_LOGGER,	"x":x++, 	"y":y, "node-count": 2});
			x = 0;
			y++;
			_nodes.push({"type":_NODE_TYPE_MONITOR,	"x":x, 	"y":y});			
			_nodes.push({"type":_NODE_TYPE_DISPATCHER,	"x":x++, 	"y":y});
				
			_arrows[1] = {};
			_arrows[1][0] = {"p0":1,"p1":0};
									

			_preCanvas = document.getElementById("preCanvas");
			_postCanvas = document.getElementById("postCanvas");
			_addNodeEl = document.getElementById("createNodeDiv");
			
			_canvas = document.getElementById("theCanvas");
			_canvas.style.backgroundColor = _CANVAS_COLOR;
			_context = _canvas.getContext('2d');
			_actionCanvas = document.getElementById("theActionCanvas");
			_actionCanvas.style.backgroundColor = _CANVAS_COLOR;
			_actionContext = _actionCanvas.getContext('2d');
			_gridCanvas = document.getElementById("theGridCanvas");
			_gridCanvas.style.backgroundColor = _CANVAS_COLOR;
			_gridContext = _gridCanvas.getContext('2d');
			
			
			paint();
			window.addEventListener("resize",paint);

            //DesktopContent.mouseMoveSubscriber(handleMouseMove); //causes problems because of this.style.cursor handling 
            document.body.addEventListener("mousemove",handleMouseMove);
			document.body.addEventListener("mouseup",handleMouseUp);
						
		} //end init()		

		//=====================================================================================
		//handleNodeMouseOver ~~
		function handleNodeMouseOver(e)
		{
			var id = this.id.split('-')[1] | 0;
			Debug.log("MouseOver Node id = " + id);
			
		} //end handleNodeMouseOver()
		
		//=====================================================================================
		//paint ~~
		//	paint grid and nodes based on 
		//	_grid and _nodes global variable and window size
		function paint() 
		{	
			_w = DesktopContent.getWindowWidth();
			_h = DesktopContent.getWindowHeight();
			
			console.log("_grid",_grid);
			console.log("_nodes",_nodes);
			console.log("_arrows",_arrows);

			var MIN_H = 280;
			var MIN_W = 280;
			if(_w < MIN_W)
				_w = MIN_W;
			if(_h < MIN_H)
				_h = MIN_H;
			
			Debug.log("paint w,h=" + _w + "," + _h);

			_canvas.style.width = (_w - _CANVAS_MARGIN*2) + "px";
			_canvas.style.height = (_h - _CANVAS_MARGIN*2) + "px";
			_canvas.width = (_w - _CANVAS_MARGIN*2);
			_canvas.height = (_h - _CANVAS_MARGIN*2);
			_context.clearRect(0, 0, _canvas.width, _canvas.height);
			
			_actionCanvas.style.width = (_w - _CANVAS_MARGIN*2) + "px";
			_actionCanvas.style.height = (_h - _CANVAS_MARGIN*2) + "px";
			_actionCanvas.width = (_w - _CANVAS_MARGIN*2);
			_actionCanvas.height = (_h - _CANVAS_MARGIN*2);
			_actionContext.clearRect(0, 0, _canvas.width, _canvas.height);

			_gridCanvas.style.width = (_w - _CANVAS_MARGIN*2) + "px";
			_gridCanvas.style.height = (_h - _CANVAS_MARGIN*2) + "px";
			_gridCanvas.width = (_w - _CANVAS_MARGIN*2);
			_gridCanvas.height = (_h - _CANVAS_MARGIN*2);
			_gridContext.clearRect(0, 0, _canvas.width, _canvas.height);

			drawGrid();

			//determine node size and then draw			
			_NODE_SIZE = _grid.xstep*0.5;
			if(_NODE_SIZE > _grid.ystep*0.5)
				_NODE_SIZE = _grid.ystep*0.5;
			
			_grid.rowColMap = [];
			for(var i=0;i<_nodes.length;++i)							
				drawNode(i);
			
			drawArrows();
			
		} //end paint()

		//=====================================================================================
		//drawGrid ~~
		function drawGrid() 
		{	
			//determine grid spacing
			_grid.xstep = (_w - 2*_GRID_MARGIN)/_grid.cols;			
			_grid.ystep = (_h - 2*_GRID_MARGIN)/_grid.rows;
			
			if(_grid.xstep < 0 || _grid.ystep < 0)
			{
				Debug.log("Window size is too small!",Debug.HIGH_PRIORITY);
				return;
			}
						
			_grid.x0 = _GRID_MARGIN + _grid.xstep/2;
			_grid.y0 = _GRID_MARGIN + _grid.ystep/2;
			
			//shrink margin if window is small
			if(_grid.x0 > _grid.xstep * 2)
			{
				_grid.x0 = _grid.xstep;
				_grid.xstep = (_w - 2*_grid.x0)/_grid.cols;	
				_grid.x0 = _grid.x0 + _grid.xstep/2;
			}
			if(_grid.y0 > _grid.ystep * 2)
			{
				_grid.y0 = _grid.ystep;		
				_grid.ystep = (_h - 2*_grid.ystep)/_grid.rows;
				_grid.y0 = _grid.y0 + _grid.ystep/2;
			}

			console.log("drawGrid _grid",_grid);
			
			_gridContext.save();
			_gridContext.fillStyle   	= _GRID_COLOR;
			_gridContext.shadowOffsetX 	= 2;
			_gridContext.shadowOffsetY 	= 2;
			_gridContext.shadowBlur    	= 5;
			_gridContext.shadowColor	= _SHADOW_COLOR;
			
			//_context.fillRect(10,10,100,100);
					
			var r,c;
			for(r=0;r<_grid.rows;++r)
				for(c=0;c<_grid.cols;++c)
					_gridContext.fillRect(
							(_grid.x0 + c*_grid.xstep)|0,
							(_grid.y0 + r*_grid.ystep)|0,							
							3,3 /*size w,h in pixels*/);
			
			_gridContext.restore();
		} //end drawGrid()

		//=====================================================================================
		//drawNode ~~
		//	draw a node of specified by node index 
		function drawNode(i)
		{
			var type = _nodes[i].type;
			var x = _nodes[i].x;
			var y = _nodes[i].y;
			
			//add to _grid.rowColMap
			if(_grid.rowColMap[x] == undefined) 
				_grid.rowColMap[x] = [];
			_grid.rowColMap[x][y] = i; //fill x,y position
			
			var nodeid = "node-" + i;
						
			var sz = _NODE_SIZE | 0; 
			x = (_grid.x0 + x * _grid.xstep - sz/2) | 0;
			y = (_grid.y0 + y * _grid.ystep - sz/2) | 0;
			
			Debug.log("x,y,sz = " + x + "," + y + "," + sz);
			
			var typeClass = 
					type == _NODE_TYPE_READER? "nodeReader":
					type == _NODE_TYPE_READER? "nodeBuilder":
					type == _NODE_TYPE_READER? "nodeLogger":
					type == _NODE_TYPE_READER? "nodeMonitor": "nodeDispatcher";
			
			Debug.log("nodeid = " + nodeid + "; typeClass = " + typeClass);

			//if node exists, get element
			var el = document.getElementById(nodeid);	
			var boxEl;
			if(!el) //else create it
			{
				el = document.createElement("div"); 
				el.setAttribute("class", "node " + typeClass);
				el.setAttribute("id", nodeid);
								
				//draw box, connect points, pencil, and trashcan
				var str = "";
								
				//box
				var count = _nodes[i].node-count?_nodes[i].node-count:1;
				console.log(i,count);
				for(var p=0;p<count;++p)
					str += "<div id='" + nodeid + 
						"-box' class='node-box' " +
						"style='top:" + (-p*10) + "px;" +
						"left:" + (-p*10) + "px;' " +
						"></div>";
				
				//connect points
				for(var p=0;p<4;++p)
					str += "<div id='" + nodeid + 
						"-point" + p + 
						"' class='node-point" + p +
						" node-point node-point-open' " +
						" onmouseup='handlePointMouseUp(" + 
						i + "," + p + ",event);'" +
						" onmousedown='handlePointMouseDown(" + 
						i + "," + p + ",event);'" +
						"></div>";
				
				
				el.innerHTML = str;
				_postCanvas.appendChild(el);	
				el.onmouseover = handleNodeMouseOver;	
			}			
			
			boxEl = document.getElementById(nodeid + "-box");
		
			boxEl.style.width  = sz + "px";
			boxEl.style.height = sz + "px";
			el.style.left 	= x + "px";
			el.style.top 	= y + "px";		
			
			var pointSz = 12;
			var points = el.getElementsByClassName("node-point");
			var pxy;
			for(var p=0;p<4;++p)
			{
				pxy = getNodePoint(i,p);
				points[p].style.left 	= (pxy[0] - x - pointSz/2) + "px";
				points[p].style.top 	= (pxy[1] - y - pointSz/2) + "px";
			}
			
		} //end drawNode()

		//=====================================================================================
		//drawArrows ~~
		function drawArrows() 
		{	
			var xy0,xy1;
			for(var i in _arrows)
				for(var j in _arrows[i])
				{
					xy0 = getNodePoint(i|0,_arrows[i][j].p0);
					xy1 = getNodePoint(j|0,_arrows[i][j].p1);
					console.log("xy01",xy0,xy1);
					drawArrow(xy0[0],xy0[1],xy1[0],xy1[1]);
				}
			
		} //end drawArrows()
		
		//=====================================================================================
		//drawArrow ~~
		function drawArrow(x0,y0,x,y,isActionCanvas) 
		{	
			console.log("drawArrow x0,y0,x,y,isActionCanvas ",
					x0,y0,x,y,isActionCanvas);
			
			if(isActionCanvas) //assume one at a time in action
				_actionContext.clearRect(0, 0, _canvas.width, _canvas.height);
			
			var context = isActionCanvas?_actionContext:_context;
			
			context.save();
			
			var HEAD_SZ = 10;
			var LINE_SZ = 2;
			
			//make arrow slightly shorter than full distance
			
            var angle = Math.atan2(y-y0,x-x0);
            
            x -= HEAD_SZ*Math.cos(angle);
            y -= HEAD_SZ*Math.sin(angle);
//            
//            if(x0 < x)
//            	
//            else 
//            	x += HEAD_SZ*Math.cos(angle);
//            if(y0 < y)
//            	x -= HEAD_SZ*Math.cos(angle);
//            else 
//            	x += HEAD_SZ*Math.cos(angle);
            


            //starting path of the arrow from the start square to the end square and drawing the stroke
            context.beginPath();
            context.moveTo(x0, y0);
            context.lineTo(x, y);
            context.strokeStyle = _ARROW_COLOR;
            context.lineWidth = LINE_SZ;
            context.stroke();

            //starting a new path from the head of the arrow to one of the sides of the point
            context.beginPath();
            context.moveTo(x, y);
            context.lineTo(x-HEAD_SZ*Math.cos(angle-Math.PI/7),y-HEAD_SZ*Math.sin(angle-Math.PI/7));

            //path from the side point of the arrow, to the other side point
            context.lineTo(x-HEAD_SZ*Math.cos(angle+Math.PI/7),y-HEAD_SZ*Math.sin(angle+Math.PI/7));

            //path from the side point back to the tip of the arrow, and then again to the opposite side point
            context.lineTo(x, y);
            context.lineTo(x-HEAD_SZ*Math.cos(angle-Math.PI/7),y-HEAD_SZ*Math.sin(angle-Math.PI/7));

            //draws the paths created above
            context.strokeStyle = _ARROW_COLOR;
            context.lineWidth = LINE_SZ;
            context.stroke();
            context.fillStyle = _ARROW_COLOR;
            context.fill();
            
			context.restore();
		} //end drawArrow()		

		//=====================================================================================
		//handleMouseMove ~~
		function handleMouseMove(e) 
		{	
    		var x = e.clientX;//- this.offsetLeft - _CANVAS_MARGIN - 2;
    		var y = e.clientY;//- this.offsetTop - _CANVAS_MARGIN - 2;
			
    		//console.log("mousemove x,y",x,y);
    		
    		//debug visually
    		//_context.fillRect((x)|0,(y)|0,3,3 );
    		
    		//steps:
    		//	if mousedown, draw arrow or dragging object
    		//	else if over empty grid position, show + 
    		//	else if over node show node decription/options
    		
    		
    		//----------------------------
    		//if mouse 'down' move handling
    		if(_mouseMoveMode != _MMM_NONE)
    		{
    			//handle mousemove mode
    			
    			//hide +
    			_addNodeEl.style.left = "-1000px"; //off screen
    			
    			switch(_mouseMoveMode)
    			{
    			case _MMM_ARROW_DRAG:
    				console.log("arrow drag x,y",x,y);
    				drawArrow(
    						_mouseMoveStart[0],
							_mouseMoveStart[1],
							x,y, true /*isActionCanvas*/);
    					
    				break;    			
    			default:
    				Debug.log("Illegal _mouseMoveMode = " + _mouseMoveMode, 
    						Debug.HIGH_PRIORITY);
    			}
    			
    			return;
    		} //end handle mousemove mode

    		
			var xg = ((x - _grid.x0 + _grid.xstep/2)/_grid.xstep)|0;
			var yg = ((y - _grid.y0 + _grid.ystep/2)/_grid.ystep)|0;			
			
			//console.log("mousemove x,y",x,y,
			//		"mousemove xg,yg",xg,yg);
			
			if(xg >= 0 && yg >= 0 && 
					xg < _grid.cols && 
					yg < _grid.rows)
			{
				if(_grid.rowColMap[xg] !== undefined &&
					_grid.rowColMap[xg][yg] !== undefined)
				{
					//----------------------------
					//	if over node show node decription/options
									
					Debug.log("Node over " + xg + "," + yg);
					
					//if not handled, remove +			
					_addNodeEl.style.left = "-1000px"; //off screen
														
					doNodeHover(_grid.rowColMap[xg][yg]);
					return;
				}
				else // else there is no node
				{		
					//----------------------------
					//if over empty grid position, show +
					    		
					Debug.log("Place + at " + xg + "," + yg);
	
					var sz = 32;
					_addNodeEl.style.left =
							((_grid.x0 + xg * _grid.xstep - sz/2) | 0) + "px";
					_addNodeEl.style.top =
							((_grid.y0 + yg * _grid.ystep - sz/2) | 0) + "px";					
				}
			}
			else
			{
				//if not handled, remove +			
				_addNodeEl.style.left = "-1000px"; //off screen
			}
			
			//undo cursor changes if any
			this.style.cursor = "default";	
				
			//undo hover node, if any
			if(_mouseHoverNode != -1)
				doNodeHover(_mouseHoverNode,true /*undoHover*/);
			
		} //end handleMouseMove()

		//=====================================================================================
		//handleMouseUp ~~
		function handleMouseUp(e) 
		{	
    		var x = e.clientX;
    		var y = e.clientY;
			
    		console.log("mouseup x,y",x,y);
    		    		
    		//debug visually
    		_context.fillRect((x)|0,(y)|0,3,3 );
    		
    		if(_mouseMoveMode != _MMM_NONE)
    		{
    			switch(_mouseMoveMode)
    			{
    			case _MMM_ARROW_DRAG:
    				console.log("done arrow drag NO VALID END x,y",x,y);
    				_mouseMoveMode = _MMM_NONE;
    				break;    			
    			default:
    				Debug.log("Illegal mousemove _mouseMoveMode = " +
    						_mouseMoveMode, 
    						Debug.HIGH_PRIORITY);
    			}
    		}
    		
		} //end handleMouseUp()

		//=====================================================================================
		//getNodePoint ~~
		//	returns x,y center of node point
		function getNodePoint(i,p) 
		{
			var x = _nodes[i].x;
			var y = _nodes[i].y;
			var sz = _NODE_SIZE | 0; 

			var x = (_grid.x0 + x * _grid.xstep - sz/2) | 0;
			var y = (_grid.y0 + y * _grid.ystep - sz/2) | 0;

			switch(p)
			{
			case 0: //top
				return [(x + sz/2)|0,
						(y)|0];
			case 1: //right
				return [(x + sz)|0,
						(y + sz/2)|0];
			case 2: //bottom
				return [(x + sz/2)|0,
						(y + sz - 1)|0];
			case 3: //left
				return [(x - 1)|0,
						(y + sz/2)|0];
			default:
				Debug.log("illegal point request! " + p,
						Debug.HIGH_PRIORITY);
			}
		} //end getNodePoint()
		
		//=====================================================================================
		//doNodeHover ~~
		//	handle mouse hover display of node
		function doNodeHover(i,undoHover) 
		{					
			//if attempting to hover then... 
			if(!undoHover)
			{
				//if already hovering, done
				if(_mouseHoverNode == i) return;
				//if another node was hovering, unhover it
				if(_mouseHoverNode != -1)
					doNodeHover(_mouseHoverNode,true /*undoHover*/);
				
				_mouseHoverNode = i;
			}
			else 
				_mouseHoverNode = -1; //clear mouse hover
			
			Debug.log((undoHover?"Hide ":"") + 
					"Mouse over node " + i);
			
			var nodeid = "node-" + i;
			var el = document.getElementById(nodeid);	
			var points = el.getElementsByClassName("node-point");		
			for(var p=0;p<4;++p)
				points[p].style.display = undoHover?"none":"block";

		} //end doNodeHover()

		//=====================================================================================
		//handlePointMouseDown ~~
		function handlePointMouseDown(i,p,e) 
		{	   
			e.stopPropagation();

			Debug.log("mousedown-point i,p = " +
					i + "," + p);
			
			if(_mouseMoveMode == _MMM_NONE)
			{
				Debug.log("Starting arrow drag mouseup-point i,p = " +
						i + "," + p);
				_mouseMoveMode = _MMM_ARROW_DRAG;
				_mouseMoveStart = getNodePoint(i,p);
				_mouseMoveStart[2] = i;
				_mouseMoveStart[3] = p;
			}
			
		} //end handlePointMouseDown()
		
		//=====================================================================================
		//handlePointMouseUp ~~
		function handlePointMouseUp(i,p,e) 
		{	   
			e.stopPropagation();
			
    		Debug.log("mouseup-point i,p = " +
    				i + "," + p);

    		var x = e.clientX;
    		var y = e.clientY;
    		
    		if(_mouseMoveMode != _MMM_NONE && //dragging arrow
    				i != _mouseMoveStart[2]) //and not at same starting point
    		{
				console.log("done arrow drag end-point i,p",i,p);
				_mouseMoveMode = _MMM_NONE;    	
				
				//add arrow to array if new
				if(_arrows[_mouseMoveStart[2]] === undefined)				
					_arrows[_mouseMoveStart[2]] = {};
				if(_arrows[_mouseMoveStart[2]][i] === undefined)
				{
					_arrows[_mouseMoveStart[2]][i] = 
							{"p0":_mouseMoveStart[3],
						     "p1":p 
							}; //arrow made
					paint();
				}
				else
				{
					Debug.log("Connection already exists!",
							Debug.HIGH_PRIORITY);
				}
    		}
    		
		} //end handlePointMouseUp()
		
		</script>
</head>
	

<body onload='Javascript:init();'>	
		
	<!-- body content populated by javascript paint(), etc. -->

	<div class='preloadImage' id='preloadImage-treeEditTrashIconHover'></div>
	<div class='preloadImage' id='preloadImage-treeEditIconHover'></div>

	<canvas id='theGridCanvas'></canvas>
	<div id='preCanvas'></div>
	<canvas id='theCanvas'></canvas>
	<canvas id='theActionCanvas'></canvas>
	<div id='postCanvas'></div>
		
	<div id='createNodeDiv'>
		<a id='createNode' onclick='createNode(); return false;'
				title='Create a new node'>+</a>
	</div>
</body>
	
</html>

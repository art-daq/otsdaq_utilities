<!DOCTYPE HTML>
<html lang="en">
<head>
<title>Supervisor</title>

<link rel='stylesheet' type='text/css' href='/WebPath/css/fonts.css?family=Donegal+One'>

<style type="text/css">			
			body {
				background-color: rgb(5,10,50);
			}
			
			#clearDiv {
				clear: both;
			}
			
			#calsDiv a {
				text-decoration: none;
				color: black;
			}
			
			#physicsCanvas {
				border: 0px solid gray;				
				position: absolute;
			}
			
			#error-box {
				position: absolute;
				display: none;
				border: 2px solid gray;
				background-color: rgba(153,0,51,0.8);
				overflow-y: scroll;
				overflow-x: hidden;
				padding: 5px;
				-moz-border-radius: 2px;
				-webkit-border-radius: 2px;
				border-radius: 2px;
				color: rgb(255,200,100);
				font-size: 18px;
				font-family: 'Donegal One', arial;
				text-align: center;
			}			
			
			#parameter-setup, #extras-box, #alarm-setup-box {	
				position: absolute;
				display: none;
				border: 2px solid gray;
				background-color: rgba(0,0,0,0.8);
				overflow: hidden;
				padding: 5px;
				-moz-border-radius: 2px;
				-webkit-border-radius: 2px;
				border-radius: 2px;
				color: white;
				font-size: 18px;
				font-family: 'Donegal One', arial;
				text-align: center;
			}
			
			#parameter-setup a, #extras-box a, #alarm-setup-box a,
			#error-box a
			{
				color: white;
				text-decoration: none;
				font-weight: 800;
			}
			
			#parameter-setup a:hover, #extras-box a:hover, #alarm-setup-box a:hover,
			#error-box a:hover
			{
				text-decoration: underline;
			}
    
			#parameter-setup table {	
				font-size: 12px;
            }
            
			#run-number, #extras-box {
				font-size: 14px;
            }
			#run-number {
				margin-bottom: 10px;
			}
			
			.blackout {
				position: absolute;
				display: none;
			}
						
			#blackout-desc {
				color: white;
				font-size: 20px;
				font-family: 'Donegal One', arial;
			}
						
			.progress-bar {
				background-color: #1a1a1a;
				height: 25px;
				padding: 5px;
				width: 30%;
				margin: 10px 0;			
				-moz-border-radius: 5px;
				-webkit-border-radius: 5px;
				border-radius: 5px;
				border: 1px solid white;
				-moz-box-shadow: 0 1px 5px #000 inset, 0 1px 0 #444;
				-webkit-box-shadow: 0 1px 5px #000 inset, 0 1px 0 #444;
				box-shadow: 0 1px 5px #fff 
							inset, 0 1px 0 #444;	    
				text-align: left;
			}

			.progress-bar span {
				display: inline-block;
				height: 100%;	
				-moz-border-radius: 3px;
				-webkit-border-radius: 3px;
				border-radius: 3px;
				-moz-box-shadow: 0 1px 0 rgba(255, 255, 255, .5) inset;
				-webkit-box-shadow: 0 1px 0 rgba(255, 255, 255, .5) inset;
				box-shadow: 0 1px 0 rgba(255, 255, 255, .5) inset;
		        -webkit-transition: width .1s ease-in-out;
		        /*-moz-transition: width .1s ease-in-out;	        
		        transition: width .1s ease-in-out;    */	
			}
			
			.blue span {				
				background-color: #34c2e3;   
			}
			
			.stripes span {
				-webkit-background-size: 30px 30px;
				-moz-background-size: 30px 30px;
				background-size: 30px 30px;			
				background-image: -webkit-gradient(linear, left top, right bottom,
									color-stop(.25, rgba(255, 255, 255, .15)), color-stop(.25, transparent),
									color-stop(.5, transparent), color-stop(.5, rgba(255, 255, 255, .15)),
									color-stop(.75, rgba(255, 255, 255, .15)), color-stop(.75, transparent),
									to(transparent));
				background-image: -webkit-linear-gradient(135deg, rgba(255, 255, 255, .15) 25%, transparent 25%,
									transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%,
									transparent 75%, transparent);
				background-image: -moz-linear-gradient(135deg, rgba(255, 255, 255, .15) 25%, transparent 25%,
									transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%,
									transparent 75%, transparent);
				background-image: -ms-linear-gradient(135deg, rgba(255, 255, 255, .15) 25%, transparent 25%,
									transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%,
									transparent 75%, transparent);
				background-image: -o-linear-gradient(135deg, rgba(255, 255, 255, .15) 25%, transparent 25%,
									transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%,
									transparent 75%, transparent);
				background-image: linear-gradient(135deg, rgba(255, 255, 255, .15) 25%, transparent 25%,
									transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%,
									transparent 75%, transparent);            

				-webkit-animation: animate-stripes 3s linear infinite;
				-moz-animation: animate-stripes 3s linear infinite;       		
			}

			@-webkit-keyframes animate-stripes { 
				0% {background-position: 0 0;} 100% {background-position: 60px 0;}
			}

			@-moz-keyframes animate-stripes {
				0% {background-position: 0 0;} 100% {background-position: 60px 0;}
			}
		</style>


<script type="text/JavaScript" src="/WebPath/js/Globals.js"></script>
<script type="text/JavaScript" src="/WebPath/js/Debug.js"></script>
<script type="text/JavaScript"
	src="/WebPath/js/DesktopWindowContentCode.js"></script>

<script>		

			var _CANVAS_COLOR = "rgb(5,10,50)";
			var _MARGIN = 0;
            var _MIN_WIN_SZ_FOR_BIG_STATES = 600;  //canvas must be at least this size for big state drawing
            var _MIN_WIN_SZ = 350;  //canvas is forced to at least this size
            var _SM_MODE_STATE_SZ = 40;
            var _LG_MODE_STATE_SZ = 80;
            var _CANVAS_STATE_MARGIN = 10;
            var _ARROW_MARGIN = 6;
			var _CURR_STATE_COLOR = "#8ED6FF";
			var _TRANS_STATE_COLOR = "#6EAF96";
			var _TRANS_STATE_COLOR_SEL = "#8EFFD6";
            var _TRANS_STATE_SEL_BORDER_COLOR = 'white';
            var _TRANS_STATE_BORDER_COLOR = 'gray';
            var _TRANS_TRANSLATE_PERIOD = 10; //ms period for transition motion
            var _TRANS_TRANSLATE_DURATION = 0.5; //second duration of fade
            var _TRANS_BLACKOUT_COLOR = "5,10,50";
    
            var _ARROW_PATH = [[-0.1,0],[0.1,0],[0.1,0.7],[0.3,0.7],[0,1],[-0.3,0.7],[-0.1,0.7],[-0.1,0]];
            var _ARROW_COLOR = 'rgb(155,120,50)';
            var _ARROW_BORDER_COLOR = 'gray';
            var _ARROW_SEL_COLOR = 'rgb(255,250,150)';
            var _ARROW_SEL_BORDER_COLOR = 'white';
    
            var _HUD_X = 10;
            var _HUD_Y = 10;
            var _HUD_W = 260;
            var _HUD_H = 58;
            

			var _PARAMETER_SETUP_MIN_HEIGHT = 25; 
			var _PARAMETER_SETUP_MAX_HEIGHT = 300; 
			var _PARAMETER_SETUP_WIDTH = 260; 
			
			var _EXTRAS_WIDTH = 200; 
			var _EXTRAS_HEIGHT = 65; 
			
			var _ALARM_WIDTH = 200; 
			var _ALARM_HEIGHT = 120; 
    
            var _STATE_ANGLE_OFFSET = 0;
            
            var _TRANSITION_PARAMETERS = ["ConfigurationAlias"];
            
			//functions:
				//init()
            	//initTransitionParameters()
            	//smRequestHandler(req)
            	//getCurrentState() 
            	//currStateRequestHandler(req)
            	//updateTimeInState(t)
            	//physicsLaunchHandler(req)
                //handleMouseUp(mouseEvent)
            	//getTransitionParameterData(param)
            	//transitionTimerHandler(mouseEvent)
            	//handleCheckTransitionProgress(req)
                //handleMouseMove(mouseEvent)
                //drawHudForMouseHover()
                //getTransitionSelection(x,y)
				//redrawPhysics()
				//drawCurrentStateAndTransitions()
                //drawTransition(stateIndex, x, y)
                //drawSelfTransition(stateIndex, x, y)
            	//getStateDrawingColor(i,isBorder)
            	//getTransitionDrawingColor(i,isBorder)
                //drawState(stateIndex, x, y)
            	//toggleParameterSetup()
            	//eatParameterMouseEvent(touchEvent) 
        		//showAlarmSetup()
            	//setAlarm(start)
				//displayError(err)
				//closeErrorBox()
            
			            
			var _states, _stateNames, _transitions, _transitionNames, 
                _transitionParameters, _transitionParameterValues, _transitionActions;
            //NOTE: Wildcards for transitions from every state.. -1 allows transition to self, -2 does not
    
			var _currState, _prevState;
			var _canvas, _context, _blackout, _blackoutReveal, 
				_blackoutRevealText, _blackoutRevealContent, _progressBar,
				_parameterSetup, _extrasBox, _alarmBox, _errorBox;
			
			var _timeUpdateTimeout = 0;
			var _verifyStateTimeout = 0;
			var _timeInState = 0;
			var _alarmRunning = false;
			var _alarmTimeLeft = 0;
			var _ALARM_SOUND_PATH = "/WebPath/sounds/fx-Alarm-Beep.wav"; // "http://www.soundjay.com/button/button-2.wav"; //must be .wav for firefox incompatibility	
			var _AlarmSound = new Audio(_ALARM_SOUND_PATH);
			
			var _parameterSetupMinimized = true;	//default to minimized
			var _parameterInitCount;
			
			var _inAnimation; //bool used to indicate if currently in transition (animation taking place)
			var _smallStateMode, _stateOvalRadius, _perimeterRadius, _currStateTransArr;
            var _selectedTransition;
            var _transitionFadeAlpha, _transitionFadeAlphaInc, _transitionTimer, _transitionProgress, 
            	_transitionResultingState;
            	
			
			/////////////////////////////////////////////////////////////////////////////////////////
			/////////////////////////////////////////////////////////////////////////////////////////
			
			//get all states and transitions
            //get current state
			//  give user possibilities based on current state and valid state transitions	
			//	gui strategy:
			//		current state in middle
			//		all transitionable states evenly spaced around circle from 3 to 9 o'clock
			//		1 of 2 things occurs
			//		  1. user click on state to start transition
			//		  2. periodic polling detects state transition
			//      for state transition...	
			//			display fades out, 
            //		*** start checking server for progress, and show progress bar
            //		*** check server for new current state
            //			display fades in (goto start of gui strategy)			
			
			//init called once body has loaded
			function init() {						
								
				_currState = -1;
				_prevState = -1;
				
				_blackout = document.getElementById("blackout");
				_blackoutReveal = document.getElementById("blackout-reveal");
				_blackoutRevealContent = document.getElementById("blackout-reveal-content");
				_blackoutRevealText = document.getElementById("blackout-desc");
				_progressBar = document.getElementById("progress-bar");
		    	_progressBar.style.width = 0 + "%"; //reset progress bar for next transition
				_parameterSetup = document.getElementById("parameter-setup");
				_parameterSetup.onmousemove = eatParameterMouseEvent;
				_parameterSetup.onmouseup = eatParameterMouseEvent;
				_extrasBox = document.getElementById("extras-box");
				_extrasBox.onmousemove = eatParameterMouseEvent;
				_extrasBox.onmouseup = eatParameterMouseEvent;
				_alarmBox = document.getElementById("alarm-setup-box");
				_alarmBox.onmousemove = eatParameterMouseEvent;
				_alarmBox.onmouseup = eatParameterMouseEvent;	
				_errorBox = document.getElementById("error-box");
				initTransitionParameters();
				
				_canvas = document.getElementById("physicsCanvas");
				_canvas.style.backgroundColor = _CANVAS_COLOR;
				_context = _canvas.getContext('2d');
				_inAnimation = false;
                _selectedTransition = -1;

				window.onresize = redrawPhysics;
				document.body.onmousemove = handleMouseMove;
				document.body.onmouseup = handleMouseUp;

				//get state machine from server
				DesktopContent.XMLHttpRequest("Request?RequestType=getStateMachine", "", smRequestHandler);	
				
				window.setTimeout(redrawPhysics,1000); //for firefox drawing glitch
				window.setTimeout(redrawPhysics,5000); //for firefox drawing glitch
				
			}

            
            //initTransitionParameters
            //	user code should call with null input parameters
            //	then code launches requests to fill parameters, _transitionParameterValues
            var _transParamsHtmlStr;
			function initTransitionParameters(req) {
				if(!req) //first time
				{
					_parameterInitCount = 0;
                    _transitionParameterValues = [];
    
                    _transParamsHtmlStr = "<table width='100%'><tr><td><b><u>Parameter</u></b></td><td width='50%'><b><u>Value</u></b></td></tr>";
				}
                else
                {
                    //get parameters from req
                    Debug.log("Physics initTransitionParameters" + req.responseText);
        
                    _transParamsHtmlStr += "<tr><td>" + _TRANSITION_PARAMETERS[_parameterInitCount] +
                            "</td><td><select onchange='handleTransitionParameterChange(" +
                            _parameterInitCount + ",this);'>";
    
                    switch(_parameterInitCount)
                    {
                    case 0: //ConfigurationAlias
    
                        var aliasArr = req.responseXML.getElementsByTagName("config_alias");
                        for(var i=0;i<aliasArr.length;++i) {
                            if(aliasArr[i].getAttribute('value').indexOf("Physics") == -1) continue;
                            
                            _transParamsHtmlStr += "<option value='" + aliasArr[i].getAttribute('value') + "'>" +
                                aliasArr[i].getAttribute('value') + "</option>";
    
                            if(!i) _transitionParameterValues[i] = aliasArr[i].getAttribute('value');
                        }
    
                        break;
                    default:;
                    }
    
                    _transParamsHtmlStr += "</select></td></tr>";
    				
                    ++_parameterInitCount;
				
                }
    
                if(_parameterInitCount >= _TRANSITION_PARAMETERS.length)
                {
                    _transParamsHtmlStr += "</table>";
                    Debug.log("Physics _transParamsHtmlStr " + _transParamsHtmlStr);
                    _parameterSetup.innerHTML += _transParamsHtmlStr; 
                    return; //done
                }
    
                //else still parameters to get, so get next                
			    Debug.log("Physics initTransitionParameters " + _TRANSITION_PARAMETERS[_parameterInitCount]);
                switch(_parameterInitCount)
                {
                case 0: //ConfigurationAlias
                    DesktopContent.XMLHttpRequest("Request?RequestType=getAliasList", "", initTransitionParameters);	
                    break;
                default:;
                }
    
			}
			
			//smRequestHandler
			//handle receiving state machine
			//xml format:
			//	<state 'X'>
			//		<state_name "aaa"/>
			//		<state_transition 'X'/>
			//		<state_transition_action 'aaa'/>
			//		<state_transition_name 'aaa'/>
			//		<state_transition 'X'/>  
			//		<state_transition_action 'aaa'/>
			//		<state_transition_name 'aaa'/> ...
			//	</state>			
			function smRequestHandler(req) {			
			    Debug.log("Physics smRequestHandler" + req.responseText);	    
			    

				var states = req.responseXML.getElementsByTagName("state");

                Debug.log("Physics smRequestHandler " + states.length);
                
                //clear state machine structures
                _states = [];
                _stateNames = [];
                _transitions = [];
                _transitionNames = [];
                _transitionParameters = [];
                _transitionActions = [];
                
                //get all states and state names
                for(var i=0;i<states.length;++i)
                {
                	_states[i] = states[i].getAttribute("value");
                	_stateNames[i] = states[i].getElementsByTagName("state_name")[0].getAttribute("value");
                }
                Debug.log("Physics _states " + _states);

                //get all transitions, names, and actions
                for(var i=0;i<states.length;++i)
                {
                	var transArr = states[i].getElementsByTagName("state_transition");
                	var transNamesArr = states[i].getElementsByTagName("state_transition_name");
                	var transParametersArr = states[i].getElementsByTagName("state_transition_parameter");
                	var transActionsArr = states[i].getElementsByTagName("state_transition_action");
                	
                	
                    for(var t=0;t<transArr.length;++t)	
						for(var j=0;j<_states.length;++j) //determine the transition state index for each transition 
							if(_states[j] == transArr[t].getAttribute("value"))
							{ 
								_transitions.push([i,j]); 
								_transitionNames.push(transNamesArr[t].getAttribute("value"));
								_transitionParameters.push(transParametersArr[t].getAttribute("value"));
								_transitionActions.push(transActionsArr[t].getAttribute("value"));
								break; 
							}
                    
                }

                Debug.log("Physics _transitions \n\t" + _transitions + "\n\t" + _transitionNames + "\n\t" + _transitionActions);
	
                getCurrentState();	
			}
			
			//getCurrentState ~~
			function getCurrentState() {
				DesktopContent.XMLHttpRequest("Request?RequestType=getCurrentState", "", currStateRequestHandler);
			}
			

			//currStateRequestHandler ~~
			//	poll current state of state machine
			function currStateRequestHandler(req,id,err) {		

            	if(!req) //error! stop handler
            	{            		
            		window.clearTimeout(_verifyStateTimeout);
            		window.clearInterval(_timeUpdateTimeout);
            		Debug.log("Error: " + err, Debug.HIGH_PRIORITY); 
            		return;
            	}
            	
			    var cs = DesktopContent.getXMLValue(req,"current_state");
			    var inTrans = DesktopContent.getXMLValue(req,"in_transition") == "1";
			    
			    Debug.log("Physics currStateRequestHandler: " + cs + " -- " + inTrans);

			    //find current state in stateNames array
                for(var i=0;i<_stateNames.length;++i)
                	if(_stateNames[i] == cs) 
                	{                	
                		//handle time elapsed
                		if(!_alarmRunning)
                		{
							window.clearInterval(_timeUpdateTimeout);
							_timeUpdateTimeout = window.setInterval(updateTimeInState,1000);
	        			    updateTimeInState(DesktopContent.getXMLValue(req,"time_in_state"));
                		}
        			    
                		
        			    //draw current state if changed
						if(i != _currState)
						{								
							//notify if state was changed unexpectedly
							if(_currState != -1 && _transitionResultingState != i)
							{
								_prevState = -1; //invalidate previous state

							    Debug.log("State was changed unexpectedly from " + 
										_stateNames[_currState] + " to " + _stateNames[i] +
										". (Likely another user changed the state)",Debug.HIGH_PRIORITY);
								//								alert("State was changed unexpectedly from " + 
								//										_stateNames[_currState] + " to " + _stateNames[i] +
								//										". (Likely another user changed the state)");								
							}
								
							_currState = i;
							redrawPhysics();

							//update run number
							document.getElementById("run-number").innerHTML = DesktopContent.getXMLValue(req,"run_number");
						}
                		
                		window.clearTimeout(_verifyStateTimeout);
						_verifyStateTimeout = window.setTimeout(getCurrentState,10000); //verify current state every 10 seconds (and resync time elapse)
                		return;
                	}
			    _currState = -1; //no current state found
			    
			    Debug.log("Illegal state received as current state: " + cs,Debug.HIGH_PRIORITY);
			    //alert("Illegal state received as current state: " + cs);
			}
			
			//updateTimeInState ~~
			//  updates time in state by 1 second if not given a time value
			function updateTimeInState(t) {
				
				if(t == undefined)
					++_timeInState;
				else
					_timeInState = t|0; //take integer values only
			    //Debug.log("Physics updateTimeInState: " + _timeInState);
				
				if(_alarmRunning)
				{ 
					if(_alarmTimeLeft > 0)
						--_alarmTimeLeft;
					else //alarmWentOff!! //make it blink
					{
						--_alarmTimeLeft;
						
						if(_alarmTimeLeft == -8) _alarmTimeLeft = 0;// = -(1+_alarmTimeLeft); //alternate between -1 and 0
						
						if(_alarmTimeLeft > -3)
						{
							//play sound alert
							_AlarmSound.src = _ALARM_SOUND_PATH; // buffers automatically when created
							_AlarmSound.play();
						}
						
						if(_alarmTimeLeft%2 == 0)
							document.getElementById("time-elapsed").style.color = "black";
						else
							document.getElementById("time-elapsed").style.color = "white";
						
						document.getElementById("time-elapsed").addEventListener("mouseup",stopAlarm);
						document.getElementById("time-elapsed").style.cursor = "pointer";
						return;
					}	
				}
				else
				{
					document.getElementById("time-elapsed").style.color = "white";
					document.getElementById("time-elapsed").removeEventListener("mouseup",stopAlarm);
					document.getElementById("time-elapsed").style.cursor = "default";
				}
				
				var showCountdown = _alarmRunning || _alarmBox.style.display == "block";	
				
				var str = showCountdown?"Countdown: ":"Elapsed: ";		
				t = showCountdown?_alarmTimeLeft:_timeInState;
				
				var hours = (t/60.0/60.0)|0;
				var mins = ((t%(60*60))/60.0)|0;
				var secs = t%60;
				
				str += hours + ":";
				if(mins < 10)	str += "0"; //keep to 2 digits
				str += mins + ":";
				if(secs < 10)	str += "0"; //keep to 2 digits
				str += secs ;
				
				document.getElementById("time-elapsed").innerHTML = str;			
			}

            //physicsLaunchHandler ~~
            //  handle response to launch of physics state change
            function physicsLaunchHandler(req) {
            	
                Debug.log("Physics physicsLaunchHandler " + req.responseText);
                
                var success = DesktopContent.getXMLValue(req,"state_tranisition_attempted") == "1";
                if(!success) 
                {
                	Debug.log("Server indicated failure to attempt state transition.",Debug.HIGH_PRIORITY);
                	//alert("Server indicated failure to attempt state transition.");
                	return;
                }
                
                //setup canvas for transition (states, no HUD)
                _context.clearRect(0, 0, _canvas.width, _canvas.height);
			    drawCurrentStateAndTransitions();
                
                //start transition
			    _blackout.style.backgroundColor = 'rgba(' + _TRANS_BLACKOUT_COLOR + ',0)';
			    _blackout.style.left = _MARGIN + "px";
			    _blackout.style.top = _MARGIN + "px";
			    _blackout.style.width = _canvas.width + "px";
			    _blackout.style.height = _canvas.height + "px";
			    _blackout.style.display = 'block';

			    _blackoutReveal.style.display = 'none';
			    _blackoutRevealContent.style.display = 'none';			    
			    _blackoutReveal.style.backgroundColor = 'rgba(' + _TRANS_BLACKOUT_COLOR + ',1)';
			    _blackoutReveal.style.left = 0 + "px";
			    _blackoutReveal.style.top = 0 + "px";
			    _blackoutReveal.style.width = _canvas.width + "px";
			    _blackoutReveal.style.height = _canvas.height + "px";
			    
                _inAnimation = true;
                _blackoutRevealText.innerHTML = _transitionNames[_currStateTransArr[_selectedTransition]] + " from " + 
                	_states[_currState] + " to " + _states[_transitions[_currStateTransArr[_selectedTransition]][1]];
                _transitionProgress = -1; //use -1 to indicate need to check
                _transitionFadeAlpha = 0;
                _transitionFadeAlphaInc =  _TRANS_TRANSLATE_PERIOD/_TRANS_TRANSLATE_DURATION/1000.0;
                _transitionTimer = setInterval(transitionTimerHandler,_TRANS_TRANSLATE_PERIOD)
            }
            
            //handleMouseUp ~~
            //  handle mouse click events
            //  if mouse is over a transition, execute transition
            function handleMouseUp(mouseEvent) {
                if(_selectedTransition == -1) return;
                    
				var transitionPostData = getTransitionParameterData(_transitionParameters[_currStateTransArr[_selectedTransition]]);
                Debug.log("Physics handleMouseUp to state " + _transitionActions[_currStateTransArr[_selectedTransition]] +
                    "?" + transitionPostData);
                DesktopContent.XMLHttpRequest("StateMachineXgiHandler?StateMachine=" + 
						_transitionActions[_currStateTransArr[_selectedTransition]], transitionPostData, physicsLaunchHandler);
            }
                    
            //getTransitionParameterData
            //  return the post data for the StateMachineXgiHandler?StateMachine call parameter
            function getTransitionParameterData(param) {
                for(var i=0;i<_TRANSITION_PARAMETERS.length;++i)
                    if(_TRANSITION_PARAMETERS[i] == param)
                        return param + "=" + _transitionParameterValues[i];
                return "";
            }    
            
            //transitionTimerHandler ~~
            //  fades out states, fades in progress, when transition complete at server fade out progress
            //  and finally fade in new state
            function transitionTimerHandler(mouseEvent) {
                
                //Debug.log("Physics transitionTimerHandler to state " + _transitionFadeAlpha);
                

                if(_transitionFadeAlphaInc > 0 && _transitionFadeAlpha >= 1) //done fading out ------------------
                {                    
                    //if first time, start checking for complete with server
    			    if(_transitionProgress == -1)
    			    {             
    			    	_transitionProgress = 0;
    			    	DesktopContent.XMLHttpRequest("Request?RequestType=getCurrentState", "", handleCheckTransitionProgress);	
    			    }

                    //Debug.log("Physics _transitionProgress to state " + _transitionProgress);
                	if(_transitionProgress >= 100)    //if done with transition            	
                	{
                		if(_transitionFadeAlpha > 1) //if need to fade out progress
                		{
	                    	_blackoutReveal.style.backgroundColor = 'rgba(' + _TRANS_BLACKOUT_COLOR + ',' + (2-_transitionFadeAlpha) + ')';
	                        _transitionFadeAlpha -= _transitionFadeAlphaInc*2; //twice as fast
	                        if(_transitionFadeAlpha <= 1) _transitionFadeAlpha = 1;
                		}
                		else //start fading in to next state
                		{
        				    _blackout.style.backgroundColor = 'rgba(' + _TRANS_BLACKOUT_COLOR + ',1)'; //return blackout for fade in
            			    _blackoutRevealContent.style.display = 'none'; //remove progress completely
            			    _blackoutReveal.style.display = 'none'; //remove progress completely
            			    _prevState = _currState;
                            _currState = _transitions[_currStateTransArr[_selectedTransition]][1];
                            if(_transitionResultingState != _stateNames[_currState]) 
                            {
                            	Debug.log("Error! State result not anticipated. Attempting to re-align with server.",Debug.HIGH_PRIORITY);
                            	//alert("Error! State result not anticipated. Attempting to re-align with server.");
                				DesktopContent.XMLHttpRequest("Request?RequestType=getStateMachine", "", smRequestHandler);                            	
                            }
                            _selectedTransition = -1;
                            _context.clearRect(0, 0, _canvas.width, _canvas.height);
            			    drawCurrentStateAndTransitions();        			    
                    		_transitionFadeAlphaInc *= -1; //start fade out        

    				    	_progressBar.style.width = 0 + "%"; //reset progress bar for next transition
                		}
                	}
                	else  	//fade in progress display if necessary and update progress bar
                	{                     
                        _transitionFadeAlpha += _transitionFadeAlphaInc*2; //twice as fast
                        if(_transitionFadeAlpha >= 2) _transitionFadeAlpha = 2;
                    	_blackoutReveal.style.backgroundColor = 'rgba(' + _TRANS_BLACKOUT_COLOR + ',' + (2-_transitionFadeAlpha) + ')';
        			    _blackoutReveal.style.display = 'block';
        			    _blackoutRevealContent.style.display = 'block';		
                	}
                }              
                else if(_transitionFadeAlphaInc < 0 && _transitionFadeAlpha <= 0) //done fading in ---------------
                {
                	clearInterval(_transitionTimer);
                    _inAnimation = false;
    			    _blackout.style.display = 'none';    			    
    			    updateTimeInState(0); //reset local time in state
                    redrawPhysics(); //draw new state under blackout
                    return;
                }
            	else 														//normal fade in or fade out -------------------
            	{
                    _transitionFadeAlpha += _transitionFadeAlphaInc;
                    if(_transitionFadeAlpha > 1) _transitionFadeAlpha = 1;
                    else if(_transitionFadeAlpha < 0) _transitionFadeAlpha = 0;
    			    _blackout.style.backgroundColor = 'rgba(' + _TRANS_BLACKOUT_COLOR + ',' + _transitionFadeAlpha + ')';
            	}
            }

            //handleCheckTransitionProgress ~~
            function handleCheckTransitionProgress(req,id,err) {
            	
                //Debug.log("Physics handleCheckTransitionProgress " + req.responseText);
            	
            	if(!req) //error! stop checking progress..
            	{            		
            		Debug.log("Physics handleCheckTransitionProgress Error: " + err, Debug.HIGH_PRIORITY);
            		return;
            	}

			    var inTransition = DesktopContent.getXMLValue(req,"in_transition")=="1";			    
			    var progress = DesktopContent.getXMLValue(req,"transition_progress");		    
			    
			    _transitionResultingState = DesktopContent.getXMLValue(req,"current_state");
			    
			    if(!inTransition)
			    {
			    	_transitionProgress = 100;
			    	
					//update run number
					document.getElementById("run-number").innerHTML = DesktopContent.getXMLValue(req,"run_number");
			    }
			    else
			    {
			    	if(progress > 99) progress = 99; //if not completed with transition, make sure progress is a legal value
			    	else if(progress < 0) progress = 0;
			    	
			    	if(_transitionProgress == -1) //if first time receiving progress, setup progress view
			    	{
	            		//draw state from on left
				    	_context.clearRect(0, 0, _canvas.width, _canvas.height);
				    	drawState(_currState,_canvas.width/6,_canvas.height/2+15);
				    	drawState(_transitions[_currStateTransArr[_selectedTransition]][1],_canvas.width*5/6,_canvas.height/2+15);
					    _blackout.style.backgroundColor = 'rgba(' + _TRANS_BLACKOUT_COLOR + ',0)'; //remove blackout for to and from state display
			    	}
			    	if(progress != _transitionProgress)
			    		Debug.log("Physics handleCheckTransitionProgress " + progress);
			    	_transitionProgress = progress;
			    }

		    	_progressBar.style.width = _transitionProgress + "%";
            	
            	if(_transitionProgress < 100)	
            		window.setTimeout(function(){
            			DesktopContent.XMLHttpRequest("Request?RequestType=getCurrentState", "", handleCheckTransitionProgress);
            		},10); //attempt to get current state again in 10ms
			    	
            }
            
            //handleMouseMove ~~
            //  handle mouse movement events and set cursor style
            function handleMouseMove(mouseEvent) {
                
            	//do nothing if in transition or current state not defined
                if(_inAnimation || _currState < 0) {this.style.cursor = "default"; return;}
            
                //get mouse location on canvas
                var locX = mouseEvent.clientX - this.offsetLeft - _MARGIN - 2;
                var locY = mouseEvent.clientY - this.offsetTop - _MARGIN - 2;
                
                //check if within selection band
                var selTrans = getTransitionSelection(locX,locY);
                this.style.cursor = selTrans==-1?"default":"pointer";
            
                if(_selectedTransition != selTrans)
                {
                    _selectedTransition = selTrans;
                    redrawPhysics();
                }
            }
    
            //getTransitionSelection ~~
            //  check if within selection band
            //  return index of transition,
            //else if not over transition, return -1
            function getTransitionSelection(x,y) {
                
                var angleOff = Math.PI/(_currStateTransArr.length);
                var angle = _STATE_ANGLE_OFFSET; //be on boundaries
 
                var mouseVec = [x - _canvas.width/2, y - _canvas.height/3];
                var mouseRad = Math.sqrt(mouseVec[0]*mouseVec[0]+mouseVec[1]*mouseVec[1]);
                if(mouseRad > _stateOvalRadius + _ARROW_MARGIN && mouseRad < _perimeterRadius+_stateOvalRadius*2)
                {
                    //in selection band, so select one

                    var mang = Math.atan2(mouseVec[1],mouseVec[0]) - angle;
                    if(mang < 0) mang += 2*Math.PI; //make positive
                    
                    if(parseInt(mang/angleOff) >= _currStateTransArr.length) return -1; //only allow valid selections
                    return parseInt(mang/angleOff);
                }                
                return -1;
            }
    
			//redrawPhysics ~
			// redraw current situation at startup and when window resizes
			function redrawPhysics() {	
				
				if(_currState < 0) return; //do nothing if current state not defined
				
			    //Debug.log("Physics redrawPhysics to " + window.innerWidth + " - " + window.innerHeight);
			    if(window.innerWidth == 0) window.setTimeout(redrawPhysics,100); //for browser bug?..first time issue when not part of desktop
			    
			    var w = window.innerWidth;
			    if(w < _MIN_WIN_SZ) w=_MIN_WIN_SZ; //prevent super squeeze
			    var h = window.innerHeight;
			    if(h < _MIN_WIN_SZ) h=_MIN_WIN_SZ; //prevent super squeeze
			    _smallStateMode = (h < _MIN_WIN_SZ_FOR_BIG_STATES || w < _MIN_WIN_SZ_FOR_BIG_STATES);  //decide if room for big states
                _stateOvalRadius = (_smallStateMode?_SM_MODE_STATE_SZ:_LG_MODE_STATE_SZ)/2;              
			    
                _parameterSetup.style.left = _MARGIN + _HUD_X + "px";  
                _parameterSetup.style.top =  (h - _MARGIN - _HUD_Y  - 10 - //2 for border //-10 for padding
                		(_parameterSetupMinimized?_PARAMETER_SETUP_MIN_HEIGHT:_PARAMETER_SETUP_MAX_HEIGHT)) + "px";
                _parameterSetup.style.width = _PARAMETER_SETUP_WIDTH + "px";
                _parameterSetup.style.height = 
			    	(_parameterSetupMinimized?_PARAMETER_SETUP_MIN_HEIGHT:_PARAMETER_SETUP_MAX_HEIGHT) + "px";
                _parameterSetup.style.display = "block";
                
                
				_extrasBox.style.left = (w - _MARGIN - _HUD_X - _EXTRAS_WIDTH - 10) + "px";  
                _extrasBox.style.top =  (h - _MARGIN - _HUD_Y - 10 - //2 for border //-10 for padding
                		_EXTRAS_HEIGHT) + "px";
                _extrasBox.style.width = _EXTRAS_WIDTH + "px";
                _extrasBox.style.height = _EXTRAS_HEIGHT + "px";
                _extrasBox.style.display = "block";
                
                _alarmBox.style.left = (w/2 -_ALARM_WIDTH/2 - 5) + "px";  
                _alarmBox.style.top =  (h/2 -_ALARM_HEIGHT/2 - 5) + "px";
                _alarmBox.style.width = _ALARM_WIDTH + "px";
                _alarmBox.style.height = _ALARM_HEIGHT + "px";
                
			    _canvas.style.left = _MARGIN + "px";
			    _canvas.style.top = _MARGIN + "px";
			    _canvas.style.width = (w - _MARGIN*2) + "px";
			    _canvas.style.height = (h - _MARGIN*2) + "px";
			    _canvas.width = (w - _MARGIN*2);
			    _canvas.height = (h - _MARGIN*2);
			    _context.clearRect(0, 0, _canvas.width, _canvas.height);
                
                _perimeterRadius = (_canvas.width<_canvas.height?_canvas.width:_canvas.height)/2 -
                    _CANVAS_STATE_MARGIN - _stateOvalRadius*2;
                
			    if(!_inAnimation)
                {
			    	drawCurrentStateAndTransitions();
                    //if(_selectedTransition != -1) 
                    drawHudForMouseHover(); //display text description for mouse hover
                }
			}
    
            //drawHudForMouseHover ~~
            //  draw HUD for mouse over transitions
            function drawHudForMouseHover() {
                
                _context.save(); //matching save/restore 1
                
                //draw box
                _context.beginPath();
                _context.moveTo(_HUD_X,         _HUD_Y);
                _context.lineTo(_HUD_X+_HUD_W,  _HUD_Y);
                _context.lineTo(_HUD_X+_HUD_W,  _HUD_Y+_HUD_H);
                _context.lineTo(_HUD_X,         _HUD_Y+_HUD_H);
                _context.lineTo(_HUD_X,         _HUD_Y);

                _context.closePath();
				_context.fillStyle = 'rgba(0,0,0,0.8)';
                _context.fill();

                
                //draw shadow border
				_context.lineWidth = 1;
				_context.strokeStyle = 'white';
				_context.stroke();

                //apply text
				_context.font = '14pt Donegal One';
				_context.textAlign = 'left';
				_context.fillStyle = 'white';
                _context.textBaseline = 'top';
                
                var m = 5;
                var f = 24;
                var x = _HUD_X + m;
                var y = _HUD_Y + m;
                
                if(_selectedTransition != -1)
                {
	                //_context.fillText("Click to " + _transitionActions[_currStateTransArr[_selectedTransition]], x, y);
	                _context.fillText("Click to transition from ", x, y);
	                y += f;
	                _context.fillText(_stateNames[_currState] + " to " + _stateNames[_transitions[_currStateTransArr[_selectedTransition]][1]], x, y);
                }
                else
                {
	                _context.fillText("The current state is ", x, y);
	                y += f;
	                _context.fillText(_stateNames[_currState], x, y);
                }
                	
				_context.restore(); //matching save/restore 1
                
            }

			//drawCurrentStateAndTransitions ~~
			//	called to draw current state, _currState, in middle
            //	previous state above and display valid transitions below
			function drawCurrentStateAndTransitions() {
				
                //draw current state at center
				drawState(_currState,_canvas.width/2,_canvas.height/3);
			
                //draw previous state at top
				if(_prevState != -1) drawState(_prevState,_canvas.width/2+_perimeterRadius,_canvas.height/2-_perimeterRadius);
                
                //get all of transitions for currState
                _currStateTransArr = new Array();
                var cnt = 0;
                for(var i=0;i<_transitions.length;++i)
                    if(_transitions[i][0] == -1 ||
                       (_transitions[i][0] == -2 && _transitions[i][0] != _currState) ||
                        _transitions[i][0] == _currState)
                        _currStateTransArr[cnt++] = i;//_transitions[i][1];
            
                var angleOff = Math.PI/_currStateTransArr.length;                
                var angle = angleOff/2 + _STATE_ANGLE_OFFSET;
                
                //draw each state around circle at radius                
                for(var i=0;i<_currStateTransArr.length;++i,angle += angleOff)
                {
                    if(_transitions[_currStateTransArr[i]][1] == _currState) //special loop back transition case
                    {
                        drawSelfTransition(_transitions[_currStateTransArr[i]][1],
                                           _perimeterRadius * Math.cos(angle),
                                           _perimeterRadius * Math.sin(angle));
                        continue;
                    }
                    drawState(_transitions[_currStateTransArr[i]][1],
                              _canvas.width/2 + _perimeterRadius * Math.cos(angle),
                              _canvas.height/3 + _perimeterRadius * Math.sin(angle));
                    
                    drawTransition(_transitions[_currStateTransArr[i]][1],
                                   _perimeterRadius * Math.cos(angle),
                                   _perimeterRadius * Math.sin(angle));
                }
                
			}


			//drawTransition
			//	draws arrow for state transition towards x, y
			function drawTransition(stateIndex, x, y) {
				var isSelected = _selectedTransition != -1 && stateIndex == _transitions[_currStateTransArr[_selectedTransition]][1];
                var mag = Math.sqrt(x*x+y*y);
                var up = [x/mag,y/mag];
                var lt = [y/mag,-x/mag];
                var arrowOff = _stateOvalRadius*2 + _ARROW_MARGIN;
                var arrowSz = _perimeterRadius - arrowOff*2;
                
				_context.save(); //matching save/restore 1
                
				_context.fillStyle = getTransitionDrawingColor(stateIndex);
                _context.beginPath();
                _context.moveTo(_canvas.width/2 + arrowOff*up[0] +
                                (_ARROW_PATH[0][0]*lt[0] + _ARROW_PATH[0][1]*up[0])*arrowSz,
                                 _canvas.height/3 + arrowOff*up[1] +
                                (_ARROW_PATH[0][0]*lt[1] + _ARROW_PATH[0][1]*up[1])*arrowSz);
                for(var i=0;i<_ARROW_PATH.length;++i)
                    _context.lineTo(_canvas.width/2 + arrowOff*up[0] +
                                    (_ARROW_PATH[i][0]*lt[0] + _ARROW_PATH[i][1]*up[0])*arrowSz,
                                 _canvas.height/3 + arrowOff*up[1] +
                                    (_ARROW_PATH[i][0]*lt[1] + _ARROW_PATH[i][1]*up[1])*arrowSz);
                _context.closePath();
                _context.fill();
            
                //draw shadow border
                _context.save();
				_context.lineWidth = 5;
				_context.strokeStyle = getTransitionDrawingColor(stateIndex,1);
				_context.shadowColor = 'black';
				_context.shadowBlur = 10;
				_context.shadowOffsetX = 0;
				_context.shadowOffsetY = 0;
				_context.stroke();
				_context.restore();
				
				if(isSelected) //add text for action if arrow is selected
				{
					var rw = 150;
					var rh = 40;
					//background rectangle
					_context.beginPath();
					_context.rect(_canvas.width/2 + (arrowOff+arrowSz/2)*up[0] - rw/2, 
							_canvas.height/3 + (arrowOff+arrowSz/2)*up[1] -rh/2-9, 
							rw, rh);
					_context.fillStyle = 'rgba(255,255,255,1)';
					_context.fill();
					_context.lineWidth = 3;
					_context.strokeStyle = _TRANS_STATE_COLOR;
					_context.shadowColor = 'black'; //add shadow
					_context.shadowBlur = 10;
					_context.shadowOffsetX = 0;
					_context.shadowOffsetY = 0;
					_context.stroke();
				      
					//apply text
					_context.font = '18pt Donegal One';
					_context.textAlign = 'center';
					_context.fillStyle = '#54967e';
					_context.shadowColor = 'gray';
					_context.shadowBlur = 1;
					_context.shadowOffsetX = 0;
					_context.shadowOffsetY = 0;
                    _context.fillText(_transitionActions[_currStateTransArr[_selectedTransition]],
                    		_canvas.width/2 + (arrowOff+arrowSz/2)*up[0],
                    		_canvas.height/3 + (arrowOff+arrowSz/2)*up[1]);

				}
                
				_context.restore(); //matching save/restore 1
            }
            
			//drawSelfTransition
			//	draws loop-back arrow for self state transition
			function drawSelfTransition(stateIndex, x, y) {
                var mag = Math.sqrt(x*x+y*y);
                var up = [x/mag,y/mag]; //from canvas center towards state pos
                var innerRadius = _stateOvalRadius*2-
                    (_perimeterRadius - (_stateOvalRadius*2 + _ARROW_MARGIN)*2)*0.2; //make arrows all same width
                var outerRadius = _stateOvalRadius*2;
                var arrowPos = [_canvas.width/2 + (_stateOvalRadius*2 + outerRadius + _ARROW_MARGIN*2)*up[0],
                                _canvas.height/3 + (_stateOvalRadius*2 + outerRadius + _ARROW_MARGIN*2)*up[1]];
                
                var startAng = Math.atan2(y,x) - 2*Math.PI/3;
                var finalAng = startAng - 2*Math.PI/3;
				_context.save(); //matching save/restore 1
                
                _context.beginPath();
                _context.moveTo(arrowPos[0] + innerRadius*Math.cos(startAng),
                                arrowPos[1] + innerRadius*Math.sin(startAng));
				_context.arc(arrowPos[0], arrowPos[1], innerRadius, startAng, finalAng, false);
                _context.lineTo(arrowPos[0] + outerRadius*Math.cos(finalAng),
                                arrowPos[1] + outerRadius*Math.sin(finalAng));
				_context.arc(arrowPos[0], arrowPos[1], outerRadius,  finalAng, startAng, true);
                
                //draw arrow from here
                var lt = [-outerRadius*Math.cos(startAng), -outerRadius*Math.sin(startAng)] //towards center
                mag = Math.sqrt(lt[0]*lt[0]+lt[1]*lt[1]);
                lt[0] /= mag; lt[1] /= mag;
                up = [-lt[1],lt[0]]; //pointing direction
                
                var drawPos = [arrowPos[0] + outerRadius*Math.cos(startAng),
                               arrowPos[1] + outerRadius*Math.sin(startAng)]; //setup starting position
                var arrowSz = (_perimeterRadius - (_stateOvalRadius*2 + _ARROW_MARGIN)*2); //match other arrow size
                var jutSz = 0.1;
                var pointSz = 0.3;
                
                drawPos[0] += -lt[0]*(arrowSz*jutSz); drawPos[1] += -lt[1]*(arrowSz*jutSz);//jut right
                _context.lineTo(drawPos[0],drawPos[1]);
                drawPos[0] += lt[0]*(arrowSz*jutSz+(outerRadius-innerRadius)/2) + up[0]*(arrowSz*pointSz);
                drawPos[1] += lt[1]*(arrowSz*jutSz+(outerRadius-innerRadius)/2) + up[1]*(arrowSz*pointSz); //to arrow point
                _context.lineTo(drawPos[0],drawPos[1]);
                drawPos[0] += lt[0]*(arrowSz*jutSz+(outerRadius-innerRadius)/2) - up[0]*(arrowSz*pointSz);
                drawPos[1] += lt[1]*(arrowSz*jutSz+(outerRadius-innerRadius)/2) - up[1]*(arrowSz*pointSz); //jut left
                _context.lineTo(drawPos[0],drawPos[1]);
                _context.lineTo(arrowPos[0] + innerRadius*Math.cos(startAng),
                                arrowPos[1] + innerRadius*Math.sin(startAng)); //to finishing point
                
                _context.closePath();
				_context.fillStyle = getTransitionDrawingColor(stateIndex);
                _context.fill();                
                
                //draw shadow border
                _context.save();
				_context.lineWidth = 5;
				_context.strokeStyle = getTransitionDrawingColor(stateIndex,1);
				_context.shadowColor = 'black';
				_context.shadowBlur = 10;
				_context.shadowOffsetX = 0;
				_context.shadowOffsetY = 0;
				_context.stroke();
				_context.restore();
                
				_context.restore(); //matching save/restore 1
            }

			//getStateDrawingColor 
			//	return proper color for drawing based on state index i
			function getStateDrawingColor(i, isBorder) {				
				if(i == _currState) return isBorder?_TRANS_STATE_SEL_BORDER_COLOR:_CURR_STATE_COLOR;
				else if(_selectedTransition != -1 && 
						_transitions[_currStateTransArr[_selectedTransition]][1] == i)
					return isBorder?_TRANS_STATE_SEL_BORDER_COLOR:_TRANS_STATE_COLOR_SEL;
				else 
						return isBorder?_TRANS_STATE_BORDER_COLOR:_TRANS_STATE_COLOR;
			}
			
			//getTransitionDrawingColor 
			//	return proper color for drawing based on state index i
			function getTransitionDrawingColor(i, isBorder) {
				if(_selectedTransition != -1 && 
						_transitions[_currStateTransArr[_selectedTransition]][1] == i)
					return isBorder?_ARROW_SEL_BORDER_COLOR:_ARROW_SEL_COLOR;
				else 
						return isBorder?_ARROW_BORDER_COLOR:_ARROW_COLOR;
			}
						
			//drawState
			//	draws oval for state with text and coords x, y
			function drawState(stateIndex, x, y) {	
				
				_context.save(); //matching save/restore 1                
				{
					x /= 2; //since oval requires scaling apply 2 factor
					
					// save state
					_context.save(); 
					{
						// scale_context horizontally
						_context.scale(2, 1);
						
						// drawcircle which will be stretched into an oval
						_context.beginPath();
						_context.arc(x,y, _stateOvalRadius, 0, 2 * Math.PI, false);						
						_context.fillStyle = getStateDrawingColor(stateIndex); 				
						_context.fill();
				
						// restore to original state
						_context.restore();
					}
					
					_context.save();
					{		                
						// apply styling
						_context.lineWidth = 5;
						_context.strokeStyle = getStateDrawingColor(stateIndex,1);
						_context.shadowColor = 'black';
						_context.shadowBlur = 10;
						_context.shadowOffsetX = 0;
						_context.shadowOffsetY = 0;
						_context.stroke();
						
						_context.restore();
					}
                					
	                //apply text
					_context.font = '14pt Donegal One';
					_context.textAlign = 'center';
					_context.fillStyle = _CANVAS_COLOR;
					if(_smallStateMode)
	                {
	                    _context.textBaseline = 'middle';
	                    _context.fillText(_states[stateIndex], x*2, y);
	                }
	                else
	                {
	                    _context.fillText(_stateNames[stateIndex], x*2, y);
	                    _context.fillText("("+_states[stateIndex]+")", x*2, y+24);
	                }
					
					if(stateIndex == _prevState)
					{
						_context.font = '12pt Donegal One';
						_context.fillStyle = "white";
	                    _context.fillText("Previous State", x*2, y + _stateOvalRadius + 18);
						
					}
	                
					_context.restore(); //matching save/restore 1
				}
			}
			
			//toggleParameterSetup()
			//	show/hide parameter setup pane
			function toggleParameterSetup() {
				
				_parameterSetupMinimized = !_parameterSetupMinimized;
                Debug.log("Physics toggleParameterSetup " + _parameterSetupMinimized); 
                
                
                redrawPhysics();
			}
			
			//eatParameterMouseEvent(touchEvent) 
			function eatParameterMouseEvent(mouseEvent) {
				mouseEvent.cancelBubble=true; //eat event away so state changes don't occur
			}
			
			//showAlarmSetup() ~~
			function showAlarmSetup(display)
			{
				_alarmBox.style.display = display?"block":"none";
			}

			//setAlarm() ~~
			function setAlarm(start)
			{
				if(start && !_alarmTimeLeft) //if start and alarm time is at 0, then initialize alarm time
				{
					var val = document.getElementById("alarm-time").value;
					val *= 100;
					val |= 0; //gaurantee is an integer
					val /= 100;
					if(val < 0) val = 0;
					_alarmTimeLeft = (val*60)|0;
				}
				Debug.log("Physics setAlarm " + start + " _alarmTimeLeft=" + _alarmTimeLeft); 
				
                //set alarm running
                _alarmRunning = start?true:false;
			}
			
			//stopAlarm() ~~
			function stopAlarm()
			{
				_alarmRunning = false;
				_alarmTimeLeft = 0;
			}
			
			//displayError(err) ~~
			//put new error at top of current error strings
			function displayError(err)
			{
				var el = document.getElementById("error-box-err");
				var str = el.innerHTML;				
				var d = new Date();
				
				if(str.length)
					err += "<br>...<br>";
				str = d.toLocaleDateString() + " " + d.toLocaleTimeString() + ": " +
						err.replace(/\n/g , "<br>") + str;
				
        		Debug.log("Physics displayError Error: " + str + "\n\n" + err);   
				
        		el.innerHTML = str;
				_errorBox.style.display = "block";				
			}
			
			//closeErrorBox() ~~
			function closeErrorBox()
			{
				_errorBox.style.display = "none";
				document.getElementById("error-box-err").innerHTML = ""; //clear string
			}
			
		</script>
</head>


<body onload='Javascript:init();'>

<canvas id="physicsCanvas"></canvas>

<div id='parameter-setup'>
	<a href='Javascript:toggleParameterSetup();' title='Toggle Parameter Setup Pane'>Parameter Setup</a>
	<br><br>	
</div>

<div id='extras-box'>
	<div id='run-number'></div>
	<div id='time-elapsed'></div>
	<a href='Javascript:showAlarmSetup(1);' title='Setup the Alarm'>Setup Alarm</a>
</div>
		
<div id='alarm-setup-box'>
	<center><b><u>Alarm Setup</u></b></center><br>
		
	Minutes: <input style='width:50px' id='alarm-time'/>
		<br><br>
	<a href='Javascript:setAlarm(1);' title='Start the Alarm Countdown'>Start</a>
	<a href='Javascript:setAlarm(0);' title='Start the Alarm Countdown'>Pause</a>
	<a href='Javascript:showAlarmSetup(0);' title='Close the Alarm Setup Box'>Close</a>
</div>	


<div class='blackout' id='blackout'>	

	<div id='blackout-reveal-content' style='width:100%;height:100%'>
		<table height='100%' width='100%'>
			<td valign='middle' align='center'>
				<div id='blackout-desc'>Transitioning from State to State</div>
				<div id='blackout-progress'>				
					<div class="progress-bar blue stripes">
				    	<span id='progress-bar' style="width: 100%"></span>
				    </div>			    
			    </div>
			</td>
		</table>	
	</div>
		
	<div class='blackout' id='blackout-reveal'>
	</div>

</div>
		

<div id='error-box'>
<a href="javascript:closeErrorBox()">Close Errors</a><br><br>
<div id='error-box-err'></div>
</div>

</body>

</html>

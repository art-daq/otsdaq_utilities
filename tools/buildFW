#!/bin/bash
########################################################################
# buildFW.sh.in
#
# Over-arching framework build script for art, its dependencies and
# other experiment-requested packages.
#
########################################################################
# User notes:
#
# This script will build all the SSI-provided packages requested and
# required by your experiment.
#
# The source directories for the correct version of each product are
# required to be present under the PRODUCTS directory -- a separate
# script will carry out this task.
#
# Usage: 
#
#   buildFW -h
#   buildFW <options> <product-dir> <build-spec> <bundle-spec>
#
# See buildFW -h for more details.
#
########################################################################
# Experiment release manager notes.
#
# * The base-qualifier (e.g. e4, e4:nu, e4:mu2e, etc.) is set for a given
#   release by the SSI release team, and describes a coherent set of
#   dependency versions and qualifiers for each package. This qualifier
#   should not be changed by you, the release manager.
#
# * If you add or remove link dependencies, or change dependency version
#   or qualifiers, build options, or source (via patches, for example)
#   for a package, you MUST also change the package version (within SSI
#   we tend to add a "patch" letter to the vendor-provided version). You
#   MUST therefore change the product_deps and version patch level of
#   every product which uses it in order to maintain coherency and
#   consistency. You may think this is unnecessary. In the era of C++
#   inlined code, name-mangling and (with FORTRAN) other ABI
#   requirements, different compilers and their complications, etc., you
#   would be wrong. The packages must be sufficiently uniquely labeled
#   that when one sets up a high level product (e.g. art), one and only
#   one particular qualified version of any given product must be set up
#   in the environment in order to avoid breakage of the One Definition
#   Rule or other inconsistencies and corruption.
#
########################################################################
# No user-serviceable parts below.
#
####################################
# SSI release manager notes.
#
# * The at<product>_VERSIONat items are expanded by the CMake configure
#   step.
#
# * For each product, there must be a defined function
#   build_<product>. This function should be defined in the file
#   <product-top-dir>/<product>/<version>/autobuild.sh, and conform to
#   the following rules.
#
#   1. It should expect the following arguments:
#
#     * version
#     * basequal (e.g. e4, nu:e4)
#
#   2. It should expect the following global variables to be set:
#
#     * build_type (debug, prof, opt)
#     * product_topdir
#     * maketar
#
#   3. It should expect to be in the directory
#      <product-top-dir>/<product>/<version>/.
#
#   4. It should expect to have access to the following functions:
#
#     * prep_build -- determine whether package should be built.
#     * sort_quals -- reorder qualifiers alphabetically.
#
#   5. Any variables used must be declared local.
#
#   6. It shall call prep_build (see usage below) in order to ascertain
#      whether the product should be built and set some variables such
#      as logfile.
#
#   7. It shall redirect build output to ${logfile}, which shall have
#      been set by the call to prep_build, above.
#
#   8. It shall return 0 on success (including if the product does not
#      need to be built per prep_build), and an appropriate error code
#      on failure.
#
#   9. It MUST NOT return until its build task has been completed
#      (successfully or not).
#
########################################################################

########################################################################
# usage
#
usage()
{
  print_version
  cat 1>&2 <<EOF
Usage: $(basename ${0}) [-h]
       $(basename ${0}) <options> <product_topdir> <build-spec> <bundle-spec>

Options:

  -b    Specify basequal (REQUIRED: no default).
  -f    Force already-built packages to be rebuilt.
  -h    This help.
  -l    Specify an additional manifest label.
        For instance, the geant4 build might use an optional "qt" label
  -s    Specify version set for those packages requiring it
  -t    Make package tarfiles.
  -U    Force packaged version of UPS to be built and/or made current.

Arguments:

  product_topdir   Top directory for relocatable-UPS products area.

  build-spec    debug, opt or prof.

  bundle-spec   Bundle identifier: 
                art-v2_06_03 (e.g.)

EOF
}

print_version()
{
  echo "$(basename ${0}) 2.03.01"
}

########################################################################
# set_ncores

function set_ncores() {
(( result = 0 ))
case `uname -s` in
    Darwin)
        (( result = `sysctl -n hw.ncpu` ))
        ;;
    Linux)
        (( result = `cat /proc/cpuinfo 2>/dev/null | grep -c -e '^processor'` ))
        ;;
    *)
        echo "Unknown OS: `uname -s`" 1>&2
	exit 1;
esac
(( half=${result}/2 ))
export CETPKG_J=${half}
}

########################################################################
# build_noarch replaces prep_build product version; add_to_manifest
function build_noarch() {
  local pname=${1}
  local pver=${2}
  local pqual=${3}
  prep_build -f NULL ${pname} ${pver} ${pqual}
  add_to_manifest
}

########################################################################
# prep_build
#
# Boiler-plate -- return true if the product should be built. Expect
# product name, version and colon-separated qualifier list (if
# applicable) as arguments. Optional argument: -f <flvr> if different
# from the standard flavor (NULL, for instance).
function prep_build() {
  unset curr_flvr
  while getopts :f: OPT; do
    case $OPT in
      f)
        curr_flvr="$OPTARG"
        ;;
      *)
        echo "INTERNAL ERROR: usage: prep_build called with args $@" 1>&2
        exit 2
    esac
  done
  shift $(( OPTIND - 1 ))
  OPTIND=1
  pname=${1}; shift
  pver=${1}; shift
  local quals
  if [[ -n "${1}" ]]; then
    #local noplusquals=$(sort_quals ${1//+/})
    local noplusquals=${1//+/}
    shift
    tarquals=$(tar_qualstring "${noplusquals}")
    quals=" -q +${tarquals//-/:+}"
    pquals=" -q ${tarquals//-/:}"
  else
    quals=""
    pquals=""
    tarquals=""
  fi
  [[ -n "${2}" ]] && shift
  pdotver=`echo ${pver} | sed -e 's/_/./g' | sed -e 's/^v//'`
  logfile=${logdir}/build_${pname}-${pver}-${flvr}${tarquals:+-${tarquals}}.log
  if [[ "${curr_flvr}" == "NULL" ]]; then
    pkgtar=${pname}-${pdotver}-noarch${tarquals:+-${tarquals}}.tar.bz2
  else
    pkgtar=${pname}-${pdotver}-${thisplat}${tarquals:+-${tarquals}}.tar.bz2
  fi
  # check and pull
  if ups exist ${pname} ${pver}${quals} "${@}" >/dev/null 2>&1; then
    if [[ -n "${maketar}" ]]; then
      pull_product ${pname} ${pver} ${pkgtar}
    elif (( ${force:-0} )); then
      pull_product ${pname} ${pver} ${pkgtar}
    else
      echo "INFO: Product ${pname} ${pver}${pquals} exists: use -f to force rebuild."
      return 1
    fi
  else
    pull_product ${pname} ${pver} ${pkgtar}
  fi
  # check again
  if ups exist ${pname} ${pver}${quals} "${@}" >/dev/null 2>&1; then
    if (( ${force:-0} )); then
      echo "INFO: Product ${pname} ${pver}${pquals} exists and will be rebuilt."
    else
      echo "INFO: Product ${pname} ${pver}${pquals} exists: use -f to force rebuild."
      return 1
    fi
  fi
  # this test guarantees that we have pulled and unwound the source code tarball
  if [[ ! -d "${product_topdir}/${pname}/${pver}" ]] || \
       ! cd "${product_topdir}/${pname}/${pver}"; then
    echo "ERROR: Could not change directory to ${product_topdir}/${pname}/${pver}." 1>&2
    exit 1
  fi
  echo "INFO: Building ${pname} ${pver}${pquals}."
  backup_by_mtime "${logfile}"
  return 0
}


########################################################################
# sort_quals
#
# Take a colon-separated list of qualifiers and print them rearranged in
# alphabetical order.
function sort_quals() {
  printf "${1}" | tr ':' '\n' | sort | tr '\n' ':' | sed -e 's/:$//'
}

########################################################################
# tar_qualstring
#
# Take a colon-separated list of qualifiers and return a dash-separated
# list with debug / prof, etc at the back.
function tar_qualstring() {
  local dop=$(printf "${1}" | tr ':' '\n' | \
              grep -e '^\(debug\|prof\|opt\)$' 2>/dev/null)
#  local squals=($(printf "${1}" | tr ':' '\n' | \
#                  grep -v -e "^${dop}\$" 2>/dev/null | sort) ${dop})
  local squals=($(printf "${1}" | tr ':' '\n' | \
                  grep -v -e "^${dop}\$" 2>/dev/null) ${dop})
  echo "${squals[@]}" | tr ' ' '-'
}

########################################################################
# passfail
#
# Expects prep_build to have been run, which sets ${pname}, ${pver} and
# ${pquals}.
#
# Optional argument "-m" indicating that a manifest entry should *not*
# be made for this product.
function passfail() {
  local status=$?
  local no_manifest
  while getopts :m OPT; do
    case $OPT in
      m)
        (( no_manifest = 1 ))
        ;;
      *)
        echo "INTERNAL ERROR: usage: passfail [-m] <status>"
        exit 2
    esac
  done
  shift $(( OPTIND - 1 ))
  OPTIND=1
  if (( ${status} == 0)); then # Success!
    (( ${no_manifest:-0} )) || add_to_manifest
  else
    cat 1>&2 <<EOF
Build of ${pname} ${pver}${pquals} failed with status ${status} -- please examine:

  ${logfile}

and correct deficiencies before attempting to restart the build.
EOF
    exit ${status}
  fi
}

########################################################################
# add_to_manifest
#
# Record the product's details in the build manifest file.
function add_to_manifest() {
  if [[ -n "${maketar}" ]]; then
    dotpver=`echo ${pver} | sed -e 's/_/./g' | sed -e 's/^v//'`
    local tarfile=$({ ls -1t "${product_topdir}/${pname}-${dotpver}-"*"${tarquals:+-${tarquals}}.tar"* | head -1; })
#    if [ "${pname}" = "genie_phyopt" ] || [ "${pname}" = "genie_xsec" ]
#    then
#      local tarfile=$({ ls -1t "${product_topdir}/${pname}-"*"${tarquals:+-${tarquals}}.tar"* | head -1; })
#    fi
    if [[ -f "${tarfile}" ]]; then
      tarfile=$(basename "${tarfile}")
    else
      unset tarfile
    fi
  fi
  printf "%-20s %-15s %-60s %-25s %-20s\n" "${pname}" "${pver}" "${tarfile:-notar}" "-f ${curr_flvr:-${flvr}}" "${pquals}" >>"${manifest}"
}

########################################################################
# in_manifest
#
# Check whether the given product is in the manifest.
function in_manifest() {
  local prod=${1}
  local ver=${2}
  local quals=${3}
  perl -wane '$F[0] eq "'"${prod}"'" and
                $F[1] eq "'"${ver}"'" and
                  ( ! "'"${quals}"'" or $F[6] eq "'"${quals##*[ 	]}"'" ) and
                   do { $result = 1; last; }; END { exit($result?0:1); }' "${manifest}"
}

########################################################################
# backup_by_mtime
#
# Make a backup of the specified file, named by last-modified time.
function backup_by_mtime() {
  local file=${1}
  [[ -f "${file}" ]] || return 1
  local backup_suffix
  if (( ${darwin:-0} )); then
    backup_suffix="$(date -r $(stat -f %m "${file}") +%Y%m%d_%H%M%S)"
  else
    backup_suffix="$(date -r "${file}" +%Y%m%d_%H%M%S)"
  fi
  mv "${file}" "${file}.${backup_suffix}"
}


#########################################################################
# find_ups_setup_script
#
# Find and print the correct UPS setup script.
function find_ups_setup_script() {
  if [[ -f "${product_topdir}/setup" ]]; then
     ups_setup_script=${product_topdir}/setup
  elif [[ -f "${product_topdir}/setups" ]]; then
     ups_setup_script=${product_topdir}/setups
  fi
  echo ${ups_setup_script}
}


########################################################################
# maybe_report_time.
#
# Report time required to build product
#
# Usage: maybe_report_time <start> product version
function maybe_report_time() {
  local start
  (( start = $1))
  local product=$2
  local version=$3
  local end=$(date +%s)
  local dur h m s
  (( dur = end - start ))
  if (( dur > 1 )); then
    (( h = dur / 3600 ))
    (( dur -= h * 3600 ))
    (( m = dur / 60 ))
    (( s = dur - m * 60 ))
    printf "INFO: Dealt with $product $version in "
    if (( h > 0 )); then
      printf "${h}:"
    fi
    printf "%02d:%02d\n" ${m} ${s}
  fi
}

########################################################################
# do_build
#
# Make sure we find the build_XXX function and call it.
#
# Optional argument "-m" (passed through to passfail) indicating that a
# manifest entry should *not* be made for this product.
function do_build() {
  local no_manifest
  while getopts :m OPT; do
    case $OPT in
      m)
        (( no_manifest = 1 ))
        ;;
      *)
        echo "INTERNAL ERROR: usage: do_build [-m] <prod> <ver> <quals>..."
        exit 2
    esac
  done
  shift $(( OPTIND - 1 ))
  OPTIND=1
  local product=${1}; shift
  local version=${1};
  local autobuild=${product_topdir}/${product}/${version}/autobuild.sh
  if [[ ! -e "${autobuild}" ]]; then
     # try to pull the source code
     local srcdotver=`echo ${version} | sed -e 's/_/./g' | sed -e 's/^v//'`
     local srctar=${product}-${srcdotver}-source.tar.bz2
     pull_product ${product} ${version} ${srctar}
  fi
  if [[ -r "${autobuild}" ]]; then
    source "${autobuild}" || \
      { cat 1>&2 <<EOF
ERROR: Failure sourcing autobuild file for product ${product}:
       ${autobuild}
EOF
        exit 1
      }
    local start=$(date +%s)
    eval build_${product} "$@"; passfail ${no_manifest:+-m}
    maybe_report_time ${start} "${product}" "${version}"
  else
    cat 1>&2 <<EOF
ERROR: Unable to find required autobuild file for product ${product} in
       ${autobuild}
EOF
    exit 1
  fi
}

########################################################################
# prep_pull
#
# Boiler-plate -- return true if the product should be built. Expect
# product name, version and colon-separated qualifier list (if
# applicable) as arguments. Optional argument: -f <flvr> if different
# from the standard flavor (NULL, for instance).
function prep_pull() {
  unset curr_flvr
  while getopts :f: OPT; do
    case $OPT in
      f)
        curr_flvr="$OPTARG"
        ;;
      *)
        echo "INTERNAL ERROR: usage: prep_pull called with args $@" 1>&2
        exit 2
    esac
  done
  shift $(( OPTIND - 1 ))
  OPTIND=1
  pname=${1}; shift
  pver=${1}; shift
  local quals
  if [[ -n "${1}" ]]; then
    #local noplusquals=$(sort_quals ${1//+/})
    local noplusquals=${1//+/}
    shift
    tarquals=$(tar_qualstring "${noplusquals}")
    quals=" -q +${tarquals//-/:+}"
    pquals=" -q ${tarquals//-/:}"
  else
    quals=""
    pquals=""
    tarquals=""
  fi
  [[ -n "${2}" ]] && shift
  logfile=${logdir}/build_${pname}-${pver}-${flvr}${tarquals:+-${tarquals}}.log
  if ups exist ${pname} ${pver}${quals} "${@}" >/dev/null 2>&1; then
    if (( ${force:-0} )); then
      echo "INFO: Product ${pname} ${pver}${pquals} exists and will be rebuilt."
    else
      echo "INFO: Product ${pname} ${pver}${pquals} exists: use -f to force rebuild."
      return 1
    fi
  fi
  echo "INFO: Pulling ${pname} ${pver}${pquals}."
  backup_by_mtime "${logfile}"
  return 0
}

########################################################################
function pull_product()
{
   myprod=${1}
   myver=${2}
   mytar=${3}
   if [ -z ${mytar} ]; then
      echo "tarball unspecified for ${myprod}"
      exit 1
   fi
   if [ -e ${product_topdir}/${mytar} ]; then
     if (( ${force:-0} )); then
       echo "INFO: Tarball ${product_topdir}/${mytar} exists and will be pulled again."
     else
       echo "INFO: Tarball ${product_topdir}/${mytar} exists: use -f to pull again."
       return 0
     fi
   fi
   mydist=http://scisoft.fnal.gov/scisoft/packages/${myprod}/${myver}/${mytar}
   echo "pull ${mytar}"
   cd ${product_topdir}
   local mytar_alt=${mytar/sl7/slf7}
   local mydist_alt=${mydist/sl7/slf7}
   curl --fail --silent --location --insecure -O ${mydist}  || \
   curl --fail --silent --location --insecure -O ${mydist_alt}  || \
      { cat 1>&2 <<EOF
INFO: pull of ${mydist} failed
EOF
        return 0
      }
   if [ -e ${product_topdir}/${mytar} ] ; then
     cd ${product_topdir}
     tar xf ${product_topdir}/${mytar} || return 0
   elif [ -e ${product_topdir}/${mytar_alt} ] ; then
     cd ${product_topdir}
     tar xf ${product_topdir}/${mytar_alt} || return 0
   else
     echo "INFO: could not find ${product_topdir}/${mytar}"
     return 0
   fi
   return 0
}

########################################################################
# do_pull
#
# For a few special cases 
# Used by artdaq and ds50daq for TRACE
function do_pull() {
  while getopts :n OPT; do
    case $OPT in
      n)
        (( no_build_type=1 ))
        ;;
      *)
        echo "usage: ${0##*/} [-n] product version [basequal]"
        exit 2
    esac
  done
  shift $(( OPTIND - 1 ))
  OPTIND=1

  do_pull_detail ${no_build_type:+-n} "$@"
  passfail
}

########################################################################
# do_pull_detail
#
# For a few special cases 
function do_pull_detail() {
  while getopts :n OPT; do
    case $OPT in
      n)
        (( no_build_type=1 ))
        ;;
      *)
        echo "usage: ${0##*/} [-n] product version [basequal]"
        exit 2
    esac
  done
  shift $(( OPTIND - 1 ))
  OPTIND=1

  local product=${1}; shift
  local version=${1}; shift
  local xqual=${1}
  local fullqual
  if [ -z ${xqual} ]; then
    qualdir=""
    fullqual=""
  else
    if (( ${no_build_type:-0} == 0 )); then
      qualdir="-${xqual}-${build_type}"
      fullqual="${xqual}:${build_type}"
    else
      qualdir="-${xqual}"
      fullqual="${xqual}"
    fi
  fi
  # cannot use prep_build with do_pull
  #prep_build "${farg[@]}" ${product} ${version} ${fullqual} || return 0
  prep_pull "${farg[@]}" ${product} ${version} ${fullqual} || return 0
  cd ${product_topdir}
  dotversion=`echo ${version} | sed -e 's/_/./g' | sed -e 's/^v//'`
  cat 1>&2 <<EOF
pull ${product} ${version} ${fullqual}
EOF
  ( # Throwaway environment.
    source ${ups_setup_script} >/dev/null 2>&1
    type -t ups >/dev/null 2>&1 || exit 1
    flvr=$(ups flavor)
    if [[ $(uname) == Darwin ]]; then
      flvr=$(ups flavor -2)
    else
      flvr=$(ups flavor)
    fi
    if [ -e "${UPS_DIR}/bin/ups_platform.sh" ]; then
        myplat=$(ups platform)
        mytar=${product}-${dotversion}-${myplat}${qualdir}.tar.bz2
    else
      if [ "${flvr}" = "Linux64bit+2.6-2.5" ]; then
          mytar=${product}-${dotversion}-slf5-x86_64${qualdir}.tar.bz2
      elif [ "${flvr}" = "Linux64bit+2.6-2.12" ]; then
          mytar=${product}-${dotversion}-slf6-x86_64${qualdir}.tar.bz2
      elif [ "${flvr}" = "Linux64bit+3.10-2.17" ]; then
          mytar=${product}-${dotversion}-sl7-x86_64${qualdir}.tar.bz2
      elif [ "${flvr}" = "Linux64bit+3.0-2.11.3" ]; then
          mytar=${product}-${dotversion}-su11-x86_64${qualdir}.tar.bz2
      elif [ "${flvr}" = "Linux64bit+3.13-2.19" ]; then
          mytar=${product}-${dotversion}-u14-x86_64${qualdir}.tar.bz2
      elif [ "${flvr}" = "Darwin64bit+13" ]; then
          mytar=${product}-${dotversion}-d13-x86_64${qualdir}.tar.bz2
      elif [ "${flvr}" = "Darwin64bit+14" ]; then
          mytar=${product}-${dotversion}-d14-x86_64${qualdir}.tar.bz2
      elif [ "${flvr}" = "Darwin64bit+15" ]; then
          mytar=${product}-${dotversion}-d15-x86_64${qualdir}.tar.bz2
      elif [ "${flvr}" = "Darwin64bit+16" ]; then
          mytar=${product}-${dotversion}-d16-x86_64${qualdir}.tar.bz2
      else
          mytar=${product}-${dotversion}-slf6-x86_64${qualdir}.tar.bz2
      fi
    fi
    mydist=http://scisoft.fnal.gov/scisoft/packages/${product}/${version}/${mytar}
    ##mydist=http://oink.fnal.gov/distro/packages/${product}/${mytar}
    curl --fail --silent --location --insecure -O ${mydist}  || \
    { cat 1>&2 <<EOF
ERROR: pull of ${mydist} failed
EOF
      exit 1
    }
    tar xf ${mytar} || exit 1
##    printf "%-20s %-15s %-60s %-25s %-20s\n" "${product}" "${version}" "${mytar:-notar}" "-f ${curr_flvr:-${flvr}}" "${fullqual}" >>"${manifest}"
   )
   return 0
}

########################################################################
# bootstrap_cet
#
# Get the source for a cet package and unwind it.
function bootstrap_cet() {
  local cetprod=$1
  [[ cetprod == art ]] && set -x
  local cetver=$2
  local project=${3:-${cetprod}}
  (( $(ls -1A "${product_topdir}/${cetprod}/${cetver}/src" 2>/dev/null | wc -l) == 0 )) || return 0;
  echo "INFO: Bootstrapping ${cetprod} ${cetver} from project ${project}."
  mkdir -p "${product_topdir}/${cetprod}/${cetver}" || \
   { echo "ERROR: Could not create product directory for ${cetprod} ${cetver}" 1>&2; exit 1; }
  cd "${product_topdir}/${cetprod}/${cetver}" || \
   { echo "ERROR: Could not change to product directory for ${cetprod} ${cetver}" 1>&2; exit 1; }
  mkdir -p src tar || \
   { echo "ERROR: Could create necessary directories in ${cetprod}/${cetver}" 1>&2; exit 1; }
  cd tar
  curl --fail --silent --location --insecure \
   "http://cdcvs.fnal.gov/cgi-bin/git_archive.cgi/cvs/projects/${project}.${cetver}.tbz2" \
   > "${cetprod}.${cetver}.tbz2" || \
   { echo "ERROR: Unable to obtain source from Redmine for ${cetprod} ${cetver}" 1>&2; exit 1; }
  cd ../src
  tar xf "../tar/${cetprod}.${cetver}.tbz2" || \
   { echo "ERROR: Unable to unpack source archive ${product_topdir}/${cetprod}/${cetver}/tar/${cetprod}.${cetver}.tbz2" 1>&2
     ( cd .. && rm -rf src )
     exit 1;
   }
}

########################################################################
# build_with_cmake_detail
#
# Actually ensure the presence of a particular support package (wrapped
# to ensure good pass-fail semantics).
function build_with_cmake_detail() {
  while getopts :f:q:v: OPT; do
    case $OPT in
      f)
        local farg=(-f "$OPTARG")
        ;;
      q)
        local full_quals="${OPTARG}"
        ;;
      v)
        local cmake_ver="${OPTARG}"
        ;;
      *)
        echo "Unrecognized option $OPT" 1>&2
        echo "usage: ${FUNCNAME} [-f ARG] [-q ARG] [-v ARG] [--] ARGS..." 1>&2
        exit 2
    esac
  done
  shift $(( OPTIND - 1 ))
  OPTIND=1
  local cetprod=${1}; shift
  local cetver=${1}; shift
  local compext=.bz2
  bootstrap_cet ${cetprod} ${cetver} || return $?
  prep_build "${farg[@]}" ${cetprod} ${cetver} ${full_quals} || return 0
  local sourcedir="${product_topdir}/${pname}/${pver}/src"
  local builddir="${product_topdir}/${pname}/${pver}/build/"
  if [[ -z "${cmake_ver}" ]]; then
    cmake_ver=v3_2_1
    cat 1>&2 <<EOF
WARNING: CMake version not specified to build_with_cmake:
         default (${cmake_ver}) may not work.
         Specify with build_with_cmake -v @CMAKE_VERSION@ in your
         buildcfg file.
EOF
  fi
  if ups exist cmake ${cmake_ver} >/dev/null 2>&1; then
    setup cmake ${cmake_ver}
  else
   echo "ERROR: Unable to setup cmake ${cmake_ver}"
   return 1
  fi
  mkdir -p "${builddir}" || \
   { echo "ERROR: Unable to make build directory ${builddir}" 1>&2; return 1; }
  echo "INFO: Installing ${cetprod} ${cetver}."
  ( cd ${builddir} && \
    cmake -DCMAKE_INSTALL_PREFIX="${product_topdir}" "${@}" "${sourcedir}" || \
      exit $?
    make install || exit $?
    if [[ -n "${maketar}" ]]; then
      make package && \
       mv "${pname}-"*.tar${compext} "${product_topdir}"
    fi
  ) > "${logfile}" 2>&1
}

########################################################################
# build_with_cmake
#
# build a package with cmake directly
# e.g., cosmosis_ups
function build_with_cmake() {
  while getopts :f:q:v: OPT; do
    case $OPT in
      f)
       local farg=(-f "$OPTARG")
       ;;
      q)
       local qarg=(-q "$OPTARG")
       ;;
      v)
       local varg=(-v "$OPTARG")
       ;;
      *)
        echo "usage: ${FUNCNAME} [-f ARG] [-q ARG] [-v ARG] [--] ARGS..."
        exit 2
    esac
  done
  shift $(( OPTIND - 1 ))
  OPTIND=1
  local cetprod=${1}
  local cetver=${2}
  in_manifest ${cetprod} ${cetver} && return
  local start=$(date +%s)
  build_with_cmake_detail "${farg[@]}" "${qarg[@]}" "${varg[@]}" "${@}"; passfail
  maybe_report_time ${start} ${cetprod} ${cetver}
}

########################################################################
# ensure_support_package_detail
#
# Actually ensure the presence of a particular support package (wrapped
# to ensure good pass-fail semantics).
function ensure_support_package_detail() {
  while getopts :f: OPT; do
    case $OPT in
      f)
       local farg=(-f "$OPTARG")
        ;;
      *)
        echo "usage: ${0##*/} [+-f ARG} [--] ARGS..."
        exit 2
    esac
  done
  shift $(( OPTIND - 1 ))
  OPTIND=1
  local cetprod=${1}
  local cetver=${2}
  local compext
  if [[ "${cetprod}" == "cetpkgsupport" ]] &&
   ! version_greater ${cetver} v1_04_02; then
    # History.
    compext=.gz
  else
    compext=.bz2
  fi
  bootstrap_cet ${cetprod} ${cetver} || return $?
  prep_build "${farg[@]}" ${cetprod} ${cetver} || return 0
  local sourcedir="${product_topdir}/${pname}/${pver}/src"
  local builddir="${product_topdir}/${pname}/${pver}/build/"
  mkdir -p "${builddir}" || \
   { echo "ERROR: Unable to make build directory ${builddir}" 1>&2; return 1; }
  echo "INFO: Installing ${cetprod} ${cetver}."
  ( cd ${builddir} && \
    . ${sourcedir}/ups/setup_for_development || exit $?
    cmake -DCMAKE_INSTALL_PREFIX="${product_topdir}" "${sourcedir}" || exit $?
    make install || exit $?
    if [[ -n "${maketar}" ]]; then
      make package && \
       mv "${pname}-"*.tar${compext} "${product_topdir}"
    fi
  ) > "${logfile}" 2>&1
}

########################################################################
# ensure_support_package
#
# Ensure the presence of a particular support package.
function ensure_support_package() {
  while getopts :f: OPT; do
    case $OPT in
      f)
       local farg=(-f "$OPTARG")
        ;;
      *)
        echo "usage: ${0##*/} [+-f ARG} [--] ARGS..."
        exit 2
    esac
  done
  shift $(( OPTIND - 1 ))
  OPTIND=1
  local cetprod=${1}
  local cetver=${2}
  in_manifest ${cetprod} ${cetver} && return
  local start=$(date +%s)
  local cdotver=`echo ${cetver} | sed -e 's/_/./g' | sed -e 's/^v//'`
  local cettar=${cetprod}-${cdotver}-noarch.tar.bz2
  # check and pull
  if ups exist ${cetprod} ${cetver} "${@}" >/dev/null 2>&1; then
    if [[ -n "${maketar}" ]]; then
      pull_product ${cetprod} ${cetver} ${cettar}
    elif (( ${force:-0} )); then
      pull_product ${cetprod} ${cetver} ${cettar}
    else
      echo "INFO: Product ${cetprod} ${cetver} exists: use -f to force rebuild."
      return 1
    fi
  else
    pull_product ${cetprod} ${cetver} ${cettar}
  fi
  # check again
  if ups exist ${cetprod} ${cetver} "${@}" >/dev/null 2>&1; then
    if (( ${force:-0} )); then
      echo "INFO: Product ${cetprod} ${cetver} exists and will be rebuilt."
    else
      echo "INFO: Product ${cetprod} ${cetver} exists: use -f to force rebuild."
      return 1
    fi
  fi
  ensure_support_package_detail "${farg[@]}" "${@}"; passfail
  maybe_report_time ${start} ${cetprod} ${cetver}
}

########################################################################
# ensure_cetpkgsupport
#
# Make sure we have the latest cetpkgsupport
function ensure_cetpkgsupport() {
  local cetpkgver=${1}
  if [ -z ${1} ]; then cetpkgver=v1_07_01; fi
  local current_cetpkgsupport=$(ups list cetpkgsupport -K VERSION)
  ensure_support_package -f NULL cetpkgsupport ${cetpkgver}
  if version_greater "${current_cetpkgsupport}" ${cetpkgver}; then
    # Current cetpkgsupport is later than the one we want to declare current.
    echo "WARNING: not declaring old cetpkgsupport ${cetpkgver} current.x"
    echo "         Execute ups declare -c cetpkgsupport ${cetpkgver} manually."
    return
  elif ! version_greater ${cetpkgver} "${current_cetpkgsupport}"; then
    # Current cetpkgsupport *is* the one we want to declare current: NOP.
    :
  else
    # Should declare this version current.
    printf "INFO: Declaring cetpkgsupport ${cetpkgver} current."
    ups declare -c cetpkgsupport ${cetpkgver} 2>&1
  fi
}

########################################################################
# ensure_cetbuildtools
#
# Make sure we have the specified version(s) of cetbuildtools available.
function ensure_cetbuildtools() {
  local version
  while [[ -n "${1}" ]]; do
    ensure_support_package -f NULL cetbuildtools "${1}"
    shift
  done
  # set CETPKG_J for use by buildtool
  set_ncores
}

########################################################################
# build_cet_detail
#
# Actually build a CET package (wrapped to ensure good pass-fail
# semantics).
function build_cet_detail() {
  while getopts :p:n OPT; do
    case $OPT in
      n)
        (( notest=1 ))
        ;;
      p)
        local project="$OPTARG"
        ;;
      *)
        echo "usage: ${0##*/} [-p <project>] [--] product version basequal"
        exit 2
    esac
  done
  shift $(( OPTIND - 1 ))
  OPTIND=1
  
  local cetprod=$1
  local cetver=$2
  local basequal=$3
  local quals
  if [[ -n "${3}" ]]; then
    if [[ "${3}" == "-nq-" ]]; then
    basequal=""
    quals=""
    else
    quals=${3//+/}:${build_type}
    fi
  else
    basequal=""
    quals=""
  fi
  bootstrap_cet "${cetprod}" "${cetver}" ${project} || return $?

  ##ensure_cetpkgsupport || return $?
  local cetbuildtools_ver=$(perl -wne 'm&^\s*only_for_build\s+cetbuildtools\s+(\S+)& and print ${1}' \
                            ${product_topdir}/${cetprod}/${cetver}/src/ups/product_deps 2>/dev/null)
  [[ -n "${cetbuildtools_ver}" ]] && { ensure_cetbuildtools ${cetbuildtools_ver} || return $?; }
  prep_build ${cetprod} ${cetver} ${quals} || return 0

  local sourcedir="${product_topdir}/${pname}/${pver}/src"
  local builddir="${product_topdir}/${pname}/${pver}/build-${flvr}${tarquals:+-${tarquals}}"
  mkdir -p "${builddir}" || \
   { echo "ERROR: Unable to make build directory ${builddir}" 1>&2; exit 1; }
  local bti
  local testarg
  if [[ -n "${maketar}" ]]; then
    if (( ${notest:-0} == 0 )); then
      bti=-A
      testarg=-R
    else
      bti=-ip
      unset testarg
    fi
  else
    bti=-i
    if (( ${notest:-0} == 0 )); then
      testarg=-R
    else
      unset testarg
    fi
  fi
  ( cd "${builddir}"
    source "${sourcedir}/ups/setup_for_development" ${basequal} ${btopt} || exit $?
    buildtool -c -I ${product_topdir} ${bti} ${testarg} || exit $?
    if [[ -n "${maketar}" ]]; then
       mv "${pname}-"*.tar.bz2 "${product_topdir}"
    else
      :
    fi
  ) > ${logfile} 2>&1
}

########################################################################
# build_cet
#
# Build a package known to use the CET CMake build system.
function build_cet() {
  unset curr_flvr
  while getopts :f:p:n OPT; do
    case $OPT in
      f)
        curr_flvr="$OPTARG"
        ;;
      n)
        (( notest=1 ))
        ;;
      p)
        local project="$OPTARG"
        ;;
      *)
        echo "INTERNAL ERROR: usage: build_cet called with args $@" 1>&2
        echo "usage: ${0##*/} [-p <project>] [-n] [-f NULL] [--] product version basequal"
        exit 2
    esac
  done
  shift $(( OPTIND - 1 ))
  OPTIND=1

  local cetprod=$1
  local cetver=$2
  local quals
  if [[ -n "${3}" ]]; then
    if [[ "${3}" == "-nq-" ]]; then
    quals=""
    pquals=""
    tarquals=""
    else
    #local noplusquals=$(sort_quals ${1//+/})
    local noplusquals=${3//+/}:${build_type}
    tarquals=$(tar_qualstring "${noplusquals}")
    quals=" -q +${tarquals//-/:+}"
    pquals=" -q ${tarquals//-/:}"
    fi
  else
    quals=""
    pquals=""
    tarquals=""
  fi
  shift
  local start=$(date +%s)
  local cdotver=`echo ${cetver} | sed -e 's/_/./g' | sed -e 's/^v//'`
  if [[ "${curr_flvr}" == "NULL" ]]; then
    pkgtar=${cetprod}-${cdotver}-noarch${tarquals:+-${tarquals}}.tar.bz2
  else
    pkgtar=${cetprod}-${cdotver}-${thisplat}${tarquals:+-${tarquals}}.tar.bz2
  fi
  # check and pull
  if ups exist ${cetprod} ${cetver} ${quals} >/dev/null 2>&1; then
    if [[ -n "${maketar}" ]]; then
      pull_product ${cetprod} ${cetver} ${pkgtar}
    elif (( ${force:-0} )); then
      pull_product ${cetprod} ${cetver} ${pkgtar}
    else
      echo "INFO: Product ${cetprod} ${cetver} exists: use -f to force rebuild."
      pname=${cetprod}; pver=${cetver}; pquals=${pquals}; add_to_manifest
      return 1
    fi
  else
    pull_product ${cetprod} ${cetver} ${pkgtar}
  fi
  # check again
  if ups exist ${cetprod} ${cetver} ${quals} >/dev/null 2>&1; then
    if (( ${force:-0} )); then
      echo "INFO: Product ${cetprod} ${cetver} exists and will be rebuilt."
    else
      echo "INFO: Product ${cetprod} ${cetver} exists: use -f to force rebuild."
      pname=${cetprod}; pver=${cetver}; pquals=${pquals}; add_to_manifest
      return 1
    fi
  fi
  echo "calling build_cet_detail ${notest:+-n} ${project:+-p ${project}} ${cetprod} $@"
  build_cet_detail ${notest:+-n} ${project:+-p ${project}} ${cetprod} "$@"; passfail
  unset notest
  maybe_report_time ${start} ${cetprod} ${cetver}
}

########################################################################
# build_cet_null_detail
#
# Actually build a CET package (wrapped to ensure good pass-fail
# semantics).
function build_cet_null_detail() {
  while getopts :p:n OPT; do
    case $OPT in
      n)
        (( notest=1 ))
        ;;
      p)
        local project="$OPTARG"
        ;;
      *)
        echo "usage: ${0##*/} [-p <project>] [--] product version basequal"
        exit 2
    esac
  done
  shift $(( OPTIND - 1 ))
  OPTIND=1
  
  local cetprod=$1
  local cetver=$2
  local basequal=$3
  bootstrap_cet "${cetprod}" "${cetver}" ${project} || return $?

  ##ensure_cetpkgsupport || return $?
  local cetbuildtools_ver=$(perl -wne 'm&^\s*only_for_build\s+cetbuildtools\s+(\S+)& and print ${1}' \
                            ${product_topdir}/${cetprod}/${cetver}/src/ups/product_deps 2>/dev/null)
  [[ -n "${cetbuildtools_ver}" ]] && { ensure_cetbuildtools ${cetbuildtools_ver} || return $?; }
  prep_build -f NULL ${cetprod} ${cetver} ${basequal} || return 0

  local sourcedir="${product_topdir}/${pname}/${pver}/src"
  local builddir="${product_topdir}/${pname}/${pver}/build-NULL${tarquals:+-${tarquals}}"
  mkdir -p "${builddir}" || \
   { echo "ERROR: Unable to make build directory ${builddir}" 1>&2; exit 1; }
  local bti
  local testarg
  if [[ -n "${maketar}" ]]; then
    if (( ${notest:-0} == 0 )); then
      bti=-A
      testarg=-R
    else
      bti=-ip
      unset testarg
    fi
  else
    bti=-i
    if (( ${notest:-0} == 0 )); then
      testarg=-R
    else
      unset testarg
    fi
  fi
  ( cd "${builddir}"
    source "${sourcedir}/ups/setup_for_development" ${basequal} || exit $?
    # can't use buildtool at this time
    cmake -DCMAKE_INSTALL_PREFIX=${product_topdir} "${CETPKG_SOURCE}" || exit $?
    make install -j ${CETPKG_J} || exit $?
    if [[ -n ${testarg} ]]; then
      ctest -j ${CETPKG_J} || exit $?
    fi
    make package || exit $?
    if [[ -n "${maketar}" ]]; then
       mv "${pname}-"*.tar.bz2 "${product_topdir}"
    else
      :
    fi
  ) > ${logfile} 2>&1
}

########################################################################
# build_cet_null
#
# Build a package known to use the CET CMake build system.
function build_cet_null() {
  while getopts :p:n OPT; do
    case $OPT in
      n)
        (( notest=1 ))
        ;;
      p)
        local project="$OPTARG"
        ;;
      *)
        echo "usage: ${0##*/} [-p <project>] [--] product version basequal"
        exit 2
    esac
  done
  shift $(( OPTIND - 1 ))
  OPTIND=1

  local cetprod=$1
  local cetver=$2
  local start=$(date +%s)
  build_cet_null_detail ${notest:+-n} ${project:+-p ${project}} "$@"; passfail
  unset notest
  maybe_report_time ${start} ${cetprod} ${cetver}
}

########################################################################
# version_greater
#
# Compare two UPS version strings and return success if the first is
# greater.
function version_greater() {
  perl -e 'use strict;
$ARGV[0] =~ s&^\s*"([^"]+)"\s*$&${1}&;
$ARGV[1] =~ s&^\s*"([^"]+)"\s*$&${1}&;
my @v1 = ( $ARGV[0] =~ m&^v(\d+)(?:_(\d+)(?:_(\d+))?)?(.*)& );
my @v2 = ( $ARGV[1] =~ m&^v(\d+)(?:_(\d+)(?:_(\d+))?)?(.*)& );
my $result;
if (defined $v1[0] and defined $v2[0] and $v1[0] == $v2[0]) {
  if (defined $v1[1] and defined $v2[1] and $v1[1] == $v2[1]) {
    if (defined $v1[2] and defined $v2[2] and $v1[2] == $v2[2]) {
      $result = ($v1[3] and (!$v2[3] or $v1[3] gt $v2[3]))?1:0;
    } else {
      $result = (defined $v1[2] and (!defined $v2[2] or $v1[2] > $v2[2]))?1:0;
    }
  } else {
    $result = (defined $v1[1] and (!defined $v2[1] or $v1[1] > $v2[1]))?1:0;
  }
} else {
  $result = (defined $v1[0] and (!defined $v2[0] or $v1[0] > $v2[0]))?1:0
}
exit(($result == 1)? 0 : 1);
' "$@"
}

########################################################################
# bootstrap_ups
#
# Make sure we have a functioning UPS for the rest of the process.
function bootstrap_ups() {
  local ups_version=${1}
  local ups_dotversion=`echo ${ups_version} | sed -e 's/_/./g' | sed -e 's/^v//'`
  if [[ -n "$SETUP_UPS" ]]; then
    cat 1>&2 <<EOF
ERROR: Dirty environment -- UPS is set up from ${UPS_DIR}.
       Get a fresh login where UPS has not been set up.
EOF
    exit 1
  elif printenv | grep -e '^SETUP_' >/dev/null 2>&1; then
    cat 1>&2 <<EOF
ERROR: Dirty environment: detritus from earlier UPS use:
$(printenv | grep -e '^SETUP_')
       Get a fresh login where UPS has never been set up.
EOF
    exit 1
  fi
  if [[ -n "$PRODUCTS" ]]; then
    echo "INFO: PRODUCTS is set: deactivating." 1>&2
    unset PRODUCTS
  fi
  local want_ups_build
  ups_setup_script=$(find_ups_setup_script)
  if [[ -f "${ups_setup_script}" ]] && \
     [[ -d "${product_topdir}/ups/${ups_version}" ]]; then
    # Need to ascertain whether we have a later version or we really
    # want to install this one and make it current.
    ( # Throwaway environment.
      source ${ups_setup_script} >/dev/null 2>&1
      type -t ups >/dev/null 2>&1 || exit 1
      flvr=$(ups flavor)
      if [[ $(uname) == Darwin ]]; then
        flvr=$(ups flavor -2)
      else
        flvr=$(ups flavor)
      fi
      if (( $(ups list ups ${ups_version} -f ${flvr} -aK+ | wc -l) > 0 )); then
        if (( $(ups list ups ${ups_version} -f ${flvr} -aK+ | grep current | wc -l) == 0 )); then
          echo "INFO: UPS ${ups_version} exists but is not declared current."
          if (( ${force_ups:-0} )); then
            echo "INFO: Declaring current per -U option."
            ups declare -c ups ${ups_version}
          else
            echo "INFO: If you need this to be current, interrupt this script and re-execute"
            echo "      with the -U option."
            printf "\n      Pausing for 5 seconds "
            for i in 1 2 3 4 5; do printf "."; sleep 1; done
            printf "\n";
          fi
        else
          echo "INFO: UPS ${ups_version} exists and is current: nothing to do."
        fi
      else # Now need to ascertain if the current version is later or
           # earlier to see if we should build.
        local current_ups=$(ups list ups -K VERSION)
        if version_greater ${ups_version} ${current_ups}; then
          (( want_ups_build = 1 ))
        else
          echo "INFO: UPS version ${current_ups} is more recent than ${ups_version}"
          if (( ${force_ups:-0} )); then
            echo "INFO: Building anyway per -U option."
            (( want_ups_build = 1 ))
          else
            echo "INFO: If you need this to be built and declared current, interrupt this script"
            echo "      and re-execute with the -U option."
            printf "\n      Pausing for 5 seconds "
            for i in 1 2 3 4 5; do printf "."; sleep 1; done
            printf "\n";
          fi
        fi
      fi
      exit ${want_ups_build:-0}
    )
    (( want_ups_build = $? ))
  else
    # UPS not available: need it here.
    (( want_ups_build = 1 ))
  fi
  if (( ${want_ups_build:-0} )); then
    echo "INFO: Building UPS ${ups_version} for the current platform."
    local start=$(date +%s)
    local upstar=ups-${ups_dotversion}-source.tar.bz2
    cd "${product_topdir}"
    curl --fail --silent --insecure --location -O \
     "http://scisoft.fnal.gov/scisoft/packages/ups/${ups_version}/${upstar}" || \
     { echo "ERROR: Unable to obtain ${upstar} from scisoft.fnal.gov." 1>&2; exit 1; }
    tar xf "${upstar}" -C "${product_topdir}" || \
     { echo "ERROR: Unable to expand ${upstar}." 1>&2; exit 1; }
    cd "${product_topdir}/ups/${ups_version}"
    ./build_ups.sh "${product_topdir}" >& "${logdir}/build_ups-${ups_version}.log" || \
     { echo "ERROR: Unable to build UPS successfully." 1>&2; exit 1; }
##    if [[ -n "${maketar}" ]]; then
##      local tarUPS="${product_topdir}/ups/${ups_version}/tarUpsUpd.sh"
##      "${tarUPS}" "${product_topdir}" >> "${logdir}/build_ups-${ups_version}.log" 2>&1 || \
##       { echo "ERROR: Unable to make tarball from UPS with ${tarUPS}" 1>&2; exit 1; }
##    fi
    maybe_report_time ${start} UPS ${ups_version}
  fi
  # setup ups 
  setup_ups
}

########################################################################
function setup_ups
{
# Set up UPS for use here.
source "$(find_ups_setup_script)" >/dev/null 2>&1
type -t ups >/dev/null 2>&1 || \
 { cat 1>&2 <<EOF
ERROR: Unable to find a usable UPS after bootstrap! Check screen 
output and contents of build_ups-${ups_version}.log if present.
EOF
   exit 1
 }
export -f setup unsetup # So "setup" is usable in invoked scripts.
if (( ${darwin:-0} )); then
  flvr=$(ups flavor -2)
else
  flvr=$(ups flavor)
fi
thisplat=$(ups platform)
}

########################################################################
# check_ups
# double check ups version
function check_ups() {
  local upsver=${1}
  if [[ ${upsver} != ${ups_version} ]]; then
    echo "ERROR: requested ups ${upsver} but have ${ups_version}"
    exit 1
  fi
}

########################################################################
# set_extra_qualifiers
function set_extra_qualifiers() {
  case ${bqual} in
    "-") 
        bqual=""
        gccqual=""
        gcc_version=""
        ;;
    e5)
        gccqual=gcc482
        gcc_version=v4_8_2
        ;;
    e6)
        gccqual=gcc491
        gcc_version=v4_9_1        
        ;;
    e7)
        gccqual=gcc492
        gcc_version=v4_9_2
        ;;
    e8)
        gccqual=gcc520
        gcc_version=v5_2_0
        ;;
    e9)
        gccqual=gcc493
        gcc_version=v4_9_3
        ;;
    e10)
        gccqual=gcc493a
        gcc_version=v4_9_3a
        ;;
    e12)
        gccqual=gcc620
        gcc_version=v6_2_0
        ;;
    e13)
        gccqual=gcc100
        gcc_version=v1_00_00
        ;;
    e14)
       gccqual=gcc630
       gcc_version=v6_3_0
       ;;
    *)
        echo "ERROR: Unrecognized base qualifier ${bqual}." 1>&2
        exit 1
  esac
}
########################################################################
# define ifdh_version_set
# ifdh uses p276, p278, p279, p2710
function define_ifdh_version_set() {
  case ${version_set} in
    s44)
        ifdh_version_set=p2711
        ;;
    s43)
        ifdh_version_set=p2711
        ;;
    s42)
        ifdh_version_set=p2711
        ;;
    s41)
        ifdh_version_set=p2711
        ;;
    s39)
        ifdh_version_set=p2711
        ;;
    s36)
        ifdh_version_set=p2711
        ;;
    s31)
        ifdh_version_set=p2710
        ;;
    s30)
        ifdh_version_set=p2710
        ;;
    s28)
        ifdh_version_set=p2710
        ;;
    s26)
        ifdh_version_set=p2710
        ;;
    s24)
        ifdh_version_set=p2710
        ;;
    s23)
        ifdh_version_set=p2710
        ;;
    s22)
        ifdh_version_set=p2710
        ;;
    s21)
        ifdh_version_set=p2710
        ;;
    s20)
        ifdh_version_set=p2710
        ;;
    s18)
        ifdh_version_set=p2710
        ;;
    s16)
        ifdh_version_set=p2710
        ;;
    s15)
        ifdh_version_set=p279
        ;;
    s14)
        ifdh_version_set=p279
        ;;
    s13)
        ifdh_version_set=p279
        ;;
    s12)
        ifdh_version_set=p279
        ;;
    s11)
        ifdh_version_set=p279
        ;;
    s10)
        ifdh_version_set=p279
        ;;
    s8)
        ifdh_version_set=p279
        ;;
    s7)
        ifdh_version_set=p279
        ;;
    s6)
        ifdh_version_set=p278
        ;;
    s5)
        ifdh_version_set=p278
        ;;
    s4)
        ifdh_version_set=p278
        ;;
    s3)
        ifdh_version_set=p276
        ;;
    *)
        ifdh_version_set=""
  esac
}

########################################################################
# find_scriptdir
#
# Return the real location of this script. Since this could be "." we
# need to do this immediately the script starts executing, before we
# change directories.

function find_scriptdir() {
  local sdir
  local resolve_link
  while getopts :l OPT; do
    case $OPT in
      l)
        (( resolve_link = 1 ))
        ;;
      *)
        echo "usage: ${0##*/} [-l]"
        exit 2
    esac
  done
  shift $(( OPTIND - 1 ))
  OPTIND=1
  if (( ${resolve_link:-0} )) && [[ -L "${BASH_SOURCE}" ]]; then
    sdir=$(readlink "${BASH_SOURCE}")
  else
    sdir="${BASH_SOURCE}"
  fi
  ( cd "$(dirname "${sdir}")" && /bin/pwd )
}

########################################################################
# build_bundle
#
# download and build the specified bundle
# this function is called from the main bundle

function build_bundle() {
  local this_bundle=${1}
  cd ${bundle_dir}
  # first, get the bundle manifest
  this_bundle_name=`echo ${this_bundle} | cut -f1 -d"-"`
  this_bundle_dot_version=`echo ${this_bundle} | cut -f2 -d"-"`
  if [ "${this_bundle_dot_version}" = "buildcfg" ]; then
    this_bundle_dot_version=`echo ${this_bundle} | cut -f3 -d"-"`
  elif [ "${this_bundle_dot_version}" = "cfg" ]; then
    this_bundle_dot_version=`echo ${this_bundle} | cut -f3 -d"-"`
  fi
  this_bundle_version=v`echo ${this_bundle_dot_version} | sed -e 's/\./_/g'`
  if [ "${use_classic}" = "true" ]; then
    this_bundle_config=${this_bundle_name}-buildcfg-${this_bundle_dot_version}
  else
    this_bundle_config=${this_bundle_name}-cfg-${this_bundle_dot_version}
  fi
  classic_bundle_config=${this_bundle_name}-buildcfg-${this_bundle_dot_version}
  echo "pull and build ${this_bundle}"
  curl --fail --silent --location --insecure \
       -O http://scisoft.fnal.gov/scisoft/bundles/${this_bundle_name}/${this_bundle_version}/buildcfg/${this_bundle_config}  || \
      { cat 1>&2 <<EOF
ERROR: pull of ${this_bundle_config} failed
EOF
        exit 1
      }
   chmod +x ${this_bundle_config}
   # now build these products
   ( source ${bundle_dir}/${this_bundle_config} ${bqual} || exit $? )
}


########################################################################
# prep_bundle
#
# Make sure we know our bundle version and manifest filename.
function prep_bundle() {
  echo "building ${bundle_name} ${bundle_version} (${bundle_dot_version})"
  manifest=${product_topdir}/${bundle_name}-${bundle_dot_version}${flvr:+-${flvr}}${version_set:+-${version_set}}${bqual:+-${bqual}}${build_label:+-${build_label}}${build_type:+-${build_type}}_MANIFEST.txt
  backup_by_mtime "${manifest}"
  # Add UPS to the manifest.
  pname=ups; pver=${ups_version}; pquals=""; add_to_manifest
}

########################################################################
# Main body.

# Global variables.
current_os=$(uname)
[[ "${current_os}" == Darwin ]] && (( darwin = 1 ))
# Build certain products on Scientific Linux, not on Darwin or Ubuntu
build_slf_extras=0
if [ -e /usr/bin/lsb_release ]
then
  current_id=`lsb_release -is`
  [[ "${current_id}" == ScientificFermi ]] && (( build_slf_extras = 1 ))
  [[ "${current_id}" == ScientificSLF ]] && (( build_slf_extras = 1 ))
  [[ "${current_id}" == ScientificCERNSLC ]] && (( build_slf_extras = 1 ))
  [[ "${current_id}" == "SUSE LINUX" ]] && (( build_slf_extras = 1 ))
  [[ "${current_id}" == Scientific ]] && (( build_slf_extras = 1 ))
fi
build_git=${build_slf_extras}

print_version

logdir=$(/bin/pwd)
scriptdirs=("$(find_scriptdir)" "$(find_scriptdir -l)")

while getopts :b:l:fhs:tU OPT; do
  case ${OPT} in
    b)
      bqual=$OPTARG
      ;;
    l)
      build_label=$OPTARG
      ;;
    f)
      (( force = 1 ))
      ;;
    h)
      usage
      exit 1
      ;;
    s)
      version_set=$OPTARG
      ;;
    t)
      maketar=tar
      ;;
    U)
      (( force_ups = 1 ))
      ;;
    *)
      usage
      exit 1
  esac
done
shift `expr $OPTIND - 1`
OPTIND=1

if (( $# != 3 )); then
  echo "ERROR: Expected 3 non-option arguments; received $#." 1>&2
  usage
  exit 1
fi

if [ -z ${bqual} ]; then
    echo "ERROR: please specify the qualifier with -b" 1>&2
    exit 1
fi

declare readonly product_topdir="${1}"

[[ -n "$product_topdir" ]] && \
  [[ -d "${product_topdir}" ]] && \
  [[ -w "${product_topdir}" ]] || \
  { echo "ERROR: Could not write to specified product directory \"${product_topdir}\"." 1>&2; exit 1; }

if (( ${darwin:-0} )); then
  if [[ -x /usr/local/bin/homebrew ]] || [[ -x /usr/local/bin/brew ]]; then
    echo "found homebrew"
    if [  -d /usr/local/opt/openssl ]; then
      echo "using homebrew for openssl"
      echo "IMPORTANT: If other products are installed, build will not be portable!"
    else
      cat 1>&2 <<EOF
ERROR: homebrew installation detected in /usr/local. Build would
       not be portable! Move /usr/local before restarting.
EOF
      exit 1
    fi
  fi
  if [[ -x /usr/local/bin/port ]]; then
    cat 1>&2 <<EOF
ERROR: macports installation detected in /usr/local. Build would
       not be portable! Move /usr/local before restarting.
EOF
    exit 1
  fi
fi

build_type="${2}"
case ${build_type} in
  "-")
     build_type=""
     ;;
  debug)
    btopt=-d
    ;;
  opt)
    btopt=-o
    ;;
  prof)
    btopt=-p
    ;;
  *)
    echo "ERROR: Unrecognized build type \"${build_type}\"." 1>&2
    exit 1
esac

bundlename="${3}"
bundle_name=`echo ${bundlename} | cut -f1 -d"-"`
bundle_version=`echo ${bundlename} | cut -f2 -d"-"`
bundle_dot_version=`echo ${bundle_version} | sed -e 's/_/./g' | sed -e 's/^v//'`
bundle=`echo ${bundlename} | cut -f1 -d"-"`-cfg-${bundle_dot_version}
classic_bundle=`echo ${bundlename} | cut -f1 -d"-"`-buildcfg-${bundle_dot_version}
use_classic=false

if [[ -n "$bundlename" ]]; then
  for this_bundle in "${bundle}" "${classic_bundle}"; do
    for this_dir in "${scriptdirs[@]}" "${product_topdir}"; do
      if [[ -f "${this_dir}/${this_bundle}" ]]; then
        full_bundle_name="${this_dir}/${this_bundle}"
        bundle_dir="${this_dir}"
        break
      fi
    done
    [[ -n "${full_bundle_name}" ]] && break
  done
  if [[ -z "${full_bundle_name}" ]]; then
    # see if we can download the build config
    mybundle=http://scisoft.fnal.gov/scisoft/bundles/${bundle_name}/${bundle_version}/buildcfg/${bundle}
    my_classic_bundle=http://scisoft.fnal.gov/scisoft/bundles/${bundle_name}/${bundle_version}/buildcfg/${classic_bundle}
    echo "pull ${bundle}"
    cd ${product_topdir}
    curl --fail --silent --location --insecure -O ${mybundle}  || \
      { cat 1>&2 <<EOF
INFO: pull of ${mybundle} failed
EOF
      }
    curl --fail --silent --location --insecure -O ${my_classic_bundle}  || \
      { cat 1>&2 <<EOF
INFO: pull of ${my_classic_bundle} failed
EOF
      }
    if [ -e ${product_topdir}/${bundle} ]; then
      full_bundle_name="${product_topdir}/${bundle}"
      bundle_dir="${product_topdir}"
    elif [ -e ${product_topdir}/${classic_bundle} ]; then
      full_bundle_name="${product_topdir}/${classic_bundle}"
      bundle_dir="${product_topdir}"
      use_classic=true
    else
      echo "INFO: failed to download ${bundle} or ${classic_bundle}" 
      cat 1>&2 <<EOF
ERROR: Could not find specified bundle locally in the same directory as
       this script or in "${product_topdir}/${bundle}."
       Found these cfg files in those areas:
EOF
      for this_dir in "${scriptdirs[@]}" "${product_topdir}"; do
        ls ${this_dir}/*cfg* 1>&2 2>/dev/null
      done
      exit 1
    fi
  fi
else 
  echo "ERROR: Bundle is vacuous." 1>&2
  exit 1
fi

echo "Reading ${full_bundle_name}"

set_extra_qualifiers
define_ifdh_version_set

ups_version=`grep check_ups ${full_bundle_name}  | cut -f2 -d" "`
if [[ ${ups_version} ]]; then
  echo "INFO: ${full_bundle_name} specifies ups ${ups_version}"
else
  ups_version=v5_2_0
  echo "INFO: ${full_bundle_name} specifies no ups version, using ${ups_version}"
fi
ups_dotversion=`echo ${ups_version} | sed -e 's/_/./g' | sed -e 's/^v//'`
bootstrap_ups ${ups_version}

prep_bundle ${bundle}

set_ncores
echo "INFO: build will use ${CETPKG_J} cores"

echo "INFO: Assembling bundle \"$bundle\"."

source ${full_bundle_name} ${bqual} || exit $?

echo "INFO: Bundle \"$bundle\" complete."


exit $?
